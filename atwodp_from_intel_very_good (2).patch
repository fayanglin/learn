diff --git a/device/intel/cherrytrail/r2_cht_mrd/audio/audio_policy.conf b/device/intel/cherrytrail/r2_cht_mrd/audio/audio_policy.conf
index ac78e8d..3b5824e 100644
--- a/device/intel/cherrytrail/r2_cht_mrd/audio/audio_policy.conf
+++ b/device/intel/cherrytrail/r2_cht_mrd/audio/audio_policy.conf
@@ -89,14 +89,6 @@ audio_hw_modules {
         devices AUDIO_DEVICE_OUT_ALL_A2DP
       }
     }
-	inputs {
-		a2dp {
-			sampling_rates 44100|48000
-			channel_masks AUDIO_CHANNEL_IN_STEREO
-			formats AUDIO_FORMAT_PCM_16_BIT
-			devices AUDIO_DEVICE_IN_BLUETOOTH_A2DP
-		}
-	}
   }
   r_submix {
     outputs {
diff --git a/device/intel/cherrytrail/r2_cht_mrd/audio/r2_audio_policy.conf b/device/intel/cherrytrail/r2_cht_mrd/audio/r2_audio_policy.conf
index 25309ee..2a2e107 100644
--- a/device/intel/cherrytrail/r2_cht_mrd/audio/r2_audio_policy.conf
+++ b/device/intel/cherrytrail/r2_cht_mrd/audio/r2_audio_policy.conf
@@ -96,14 +96,6 @@ audio_hw_modules {
         devices AUDIO_DEVICE_OUT_ALL_A2DP
       }
     }
-	inputs {
-		a2dp {
-			sampling_rates 44100|48000
-			channel_masks AUDIO_CHANNEL_IN_STEREO
-			formats AUDIO_FORMAT_PCM_16_BIT
-			devices AUDIO_DEVICE_IN_BLUETOOTH_A2DP
-		}
-	}
   }
   r_submix {
     outputs {
diff --git a/frameworks/av/services/audioflinger/Threads.cpp b/frameworks/av/services/audioflinger/Threads.cpp
index 93f298a..71fc498 100644
--- a/frameworks/av/services/audioflinger/Threads.cpp
+++ b/frameworks/av/services/audioflinger/Threads.cpp
@@ -159,7 +159,7 @@ static const enum {
     FastCapture_Never,  // never initialize or use: for debugging only
     FastCapture_Always, // always initialize and use, even if not needed: for debugging only
     FastCapture_Static, // initialize if needed, then use all the time if initialized
-} kUseFastCapture = FastCapture_Never;
+} kUseFastCapture = FastCapture_Static;
 
 // Priorities for requestPriority
 static const int kPriorityAudioApp = 2;
diff --git a/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp b/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp
index 18c9902..0686414 100755
--- a/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp
+++ b/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp
@@ -693,18 +693,11 @@ audio_devices_t Engine::getDeviceForInputSource(audio_source_t inputSource) cons
             device = AUDIO_DEVICE_IN_REMOTE_SUBMIX;
         }
         break;
-    case AUDIO_SOURCE_FM_TUNER:
+     case AUDIO_SOURCE_FM_TUNER:
         if (availableDeviceTypes & AUDIO_DEVICE_IN_FM_TUNER) {
             device = AUDIO_DEVICE_IN_FM_TUNER;
         }
         break;
-    case AUDIO_SOURCE_BLUETOOTH_A2DP:
-        ALOGW("availableDevice: 0x%lx", availableDeviceTypes);
-        if (availableDeviceTypes & AUDIO_DEVICE_IN_BLUETOOTH_A2DP) {
-            device = AUDIO_DEVICE_IN_BLUETOOTH_A2DP;
-        }
-        break;
-
     default:
         ALOGW("getDeviceForInputSource() invalid input source %d", inputSource);
         break;
diff --git a/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java b/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
index 3e0513e..f66b5ff 100644
--- a/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
+++ b/frameworks/base/core/java/android/bluetooth/BluetoothA2dp.java
@@ -33,8 +33,6 @@ import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
-import android.content.BroadcastReceiver;
-import android.content.IntentFilter;
 
 /**
  * This class provides the public APIs to control the Bluetooth A2DP
@@ -50,7 +48,7 @@ import android.content.IntentFilter;
 public final class BluetoothA2dp implements BluetoothProfile {
     private static final String TAG = "BluetoothA2dp";
     private static final boolean DBG = true;
-    private static final boolean VDBG = true;
+    private static final boolean VDBG = false;
 
     /**
      * Intent used to broadcast the change in connection state of the A2DP
@@ -100,8 +98,6 @@ public final class BluetoothA2dp implements BluetoothProfile {
     public static final String ACTION_AVRCP_CONNECTION_STATE_CHANGED =
         "android.bluetooth.a2dp.profile.action.AVRCP_CONNECTION_STATE_CHANGED";
 
-	public static final String ACTION_A2DP_FORCE_BIND =
-        "android.bluetooth.a2dp.profile.action.A2DP_FORCE_BIND";
     /**
      * A2DP sink device is streaming music. This state can be one of
      * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
@@ -149,23 +145,6 @@ public final class BluetoothA2dp implements BluetoothProfile {
                     }
                 }
         };
-
-	private BroadcastReceiver mA2dpBroadcast =new BroadcastReceiver() {
-		@Override
-		public void onReceive(Context context, Intent intent) {
-			// TODO Auto-generated method stub
-			String action = intent.getAction();
-			String isbind = intent.getStringExtra(BluetoothProfile.EXTRA_STATE);
-			if (DBG) log(" mA2dpBroadcast onReceive!");
-			if (action.equals(ACTION_A2DP_FORCE_BIND)) {
-				if (isbind.compareTo("true") == 0) {
-					forceBind();
-				}else {		
-					forceUnbind();
-				}
-			}
-		}
-	};
     /**
      * Create a BluetoothA2dp proxy object for interacting with the local
      * Bluetooth A2DP service.
@@ -185,43 +164,8 @@ public final class BluetoothA2dp implements BluetoothProfile {
         }
 
         doBind();
-
-		IntentFilter intentFilter = new IntentFilter();
-		intentFilter.addAction(ACTION_A2DP_FORCE_BIND);
-		mContext.registerReceiver(mA2dpBroadcast, intentFilter);
     }
 
-	private void forceBind() {
-		if (mContext != null) {
-			synchronized (mConnection) {
-				if (mService == null) {
-					if (DBG) log("forceBind");
-					try {
-						doBind();
-					} catch (Exception re) {
-						Log.e(TAG,"",re);
-					}
-				}
-			}
-		}
-	}
-
-	private void forceUnbind() {
-		if (mContext != null) {
-			synchronized (mConnection) {
-				if (mService != null) {
-					if (DBG) log("forceUnbind mService="+mService);
-					try {
-						mService = null;
-						mContext.unbindService(mConnection);
-					} catch (Exception re) {
-						Log.e(TAG,"",re);
-					}
-				}
-			}
-		}
-	}
-
     boolean doBind() {
         Intent intent = new Intent(IBluetoothA2dp.class.getName());
         ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
@@ -260,9 +204,6 @@ public final class BluetoothA2dp implements BluetoothProfile {
     public void finalize() {
         // The empty finalize needs to be kept or the
         // cts signature tests would fail.
-        if (DBG) log("finalize mContext="+mContext);
-		if (mContext != null)
-        	mContext.unregisterReceiver(mA2dpBroadcast);
     }
     /**
      * Initiate connection to a profile of the remote bluetooth device.
diff --git a/frameworks/base/core/java/android/bluetooth/BluetoothA2dpSink.java b/frameworks/base/core/java/android/bluetooth/BluetoothA2dpSink.java
index d93c5e9..2e27345 100644
--- a/frameworks/base/core/java/android/bluetooth/BluetoothA2dpSink.java
+++ b/frameworks/base/core/java/android/bluetooth/BluetoothA2dpSink.java
@@ -27,8 +27,6 @@ import android.util.Log;
 import java.util.ArrayList;
 import java.util.List;
 
-import android.content.BroadcastReceiver;
-import android.content.IntentFilter;
 /**
  * This class provides the public APIs to control the Bluetooth A2DP Sink
  * profile.
@@ -42,7 +40,7 @@ import android.content.IntentFilter;
 public final class BluetoothA2dpSink implements BluetoothProfile {
     private static final String TAG = "BluetoothA2dpSink";
     private static final boolean DBG = true;
-    private static final boolean VDBG = true;
+    private static final boolean VDBG = false;
 
     /**
      * Intent used to broadcast the change in connection state of the A2DP Sink
@@ -85,8 +83,6 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
     public static final String ACTION_PLAYING_STATE_CHANGED =
         "android.bluetooth.a2dp-sink.profile.action.PLAYING_STATE_CHANGED";
 
-	public static final String ACTION_A2DP_SINK_FORCE_BIND =
-        "android.bluetooth.a2dp.profile.action.A2DP_SINK_FORCE_BIND";
     /**
      * A2DP sink device is streaming music. This state can be one of
      * {@link #EXTRA_STATE} or {@link #EXTRA_PREVIOUS_STATE} of
@@ -159,24 +155,6 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
                     }
                 }
         };
-
-	private BroadcastReceiver mA2dpSinkBroadcast =new BroadcastReceiver() {
-		@Override
-		public void onReceive(Context context, Intent intent) {
-			// TODO Auto-generated method stub
-			String action = intent.getAction();
-			String isbind = intent.getStringExtra(BluetoothProfile.EXTRA_STATE);
-			if (DBG) log(" mA2dpSinkBroadcast onReceive!");
-			if (action.equals(ACTION_A2DP_SINK_FORCE_BIND)) {
-				if (isbind.compareTo("true") == 0) {
-					forceBind();
-				}else {		
-					forceUnbind();
-				}
-			}
-
-		}
-	};
     /**
      * Create a BluetoothA2dp proxy object for interacting with the local
      * Bluetooth A2DP service.
@@ -186,9 +164,6 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
         mContext = context;
         mServiceListener = l;
         mAdapter = BluetoothAdapter.getDefaultAdapter();
-
-		if (DBG) log("BluetoothA2dpSink enter contruct funciton");
-		
         IBluetoothManager mgr = mAdapter.getBluetoothManager();
         if (mgr != null) {
             try {
@@ -199,43 +174,8 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
         }
 
         doBind();
-
-		IntentFilter intentFilter = new IntentFilter();
-		intentFilter.addAction(ACTION_A2DP_SINK_FORCE_BIND);
-		mContext.registerReceiver(mA2dpSinkBroadcast, intentFilter);
     }
 
-	private void forceBind() {
-		if (mContext != null) {
-			synchronized (mConnection) {
-				if (mService == null) {
-					if (DBG) log("forceBind");
-					try {
-						doBind();
-					} catch (Exception re) {
-						Log.e(TAG,"",re);
-					}
-				}
-			}
-		}
-	}
-
-	private void forceUnbind() {
-		if (mContext != null) {
-			synchronized (mConnection) {
-				if (mService != null) {
-					if (DBG) log("forceUnbind mService="+mService);
-					try {
-						mService = null;
-						mContext.unbindService(mConnection);
-					} catch (Exception re) {
-						Log.e(TAG,"",re);
-					}
-				}
-			}
-		}
-	}
-
     boolean doBind() {
         Intent intent = new Intent(IBluetoothA2dpSink.class.getName());
         ComponentName comp = intent.resolveSystemService(mContext.getPackageManager(), 0);
@@ -272,9 +212,6 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
     }
 
     public void finalize() {
-		if (DBG) log("finalize mContext="+mContext);
-		if (mContext != null)
-        	mContext.unregisterReceiver(mA2dpSinkBroadcast);
         close();
     }
     /**
@@ -433,68 +370,6 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
         return null;
     }
 
-	/**
-       * Set priority of the profile
-       *
-       * <p> The device should already be paired.
-       *  Priority can be one of {@link #PRIORITY_ON} orgetBluetoothManager
-       * {@link #PRIORITY_OFF},
-       *
-       * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
-       * permission.
-       *
-       * @param device Paired bluetooth device
-       * @param priority
-       * @return true if priority is set, false on error
-       * @hide
-       */
-      public boolean setPriority(BluetoothDevice device, int priority) {
-          if (DBG) log("setPriority(" + device + ", " + priority + ")");
-          if (mService != null && isEnabled()
-              && isValidDevice(device)) {
-              if (priority != BluetoothProfile.PRIORITY_OFF &&
-                  priority != BluetoothProfile.PRIORITY_ON){
-                return false;
-              }
-              try {
-                  return mService.setPriority(device, priority);
-              } catch (RemoteException e) {
-                  Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                  return false;
-              }
-          }
-          if (mService == null) Log.w(TAG, "Proxy not attached to service");
-          return false;
-      }
-
-      /**
-       * Get the priority of the profile.
-       *
-       * <p> The priority can be any of:
-       * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
-       * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
-       *
-       * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
-       *
-       * @param device Bluetooth device
-       * @return priority of the device
-       * @hide
-       */
-      public int getPriority(BluetoothDevice device) {
-          if (VDBG) log("getPriority(" + device + ")");
-          if (mService != null && isEnabled()
-              && isValidDevice(device)) {
-              try {
-                  return mService.getPriority(device);
-              } catch (RemoteException e) {
-                  Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
-                  return BluetoothProfile.PRIORITY_OFF;
-              }
-          }
-          if (mService == null) Log.w(TAG, "Proxy not attached to service");
-          return BluetoothProfile.PRIORITY_OFF;
-      }
-
     /**
      * Helper for converting a state to a string.
      *
@@ -522,7 +397,7 @@ public final class BluetoothA2dpSink implements BluetoothProfile {
 
     private final ServiceConnection mConnection = new ServiceConnection() {
         public void onServiceConnected(ComponentName className, IBinder service) {
-            if (DBG) Log.d(TAG, "Proxy object connected, service="+service);
+            if (DBG) Log.d(TAG, "Proxy object connected");
             mService = IBluetoothA2dpSink.Stub.asInterface(service);
 
             if (mServiceListener != null) {
diff --git a/frameworks/base/core/java/android/bluetooth/BluetoothAdapter.java b/frameworks/base/core/java/android/bluetooth/BluetoothAdapter.java
index b462b74..7843683 100644
--- a/frameworks/base/core/java/android/bluetooth/BluetoothAdapter.java
+++ b/frameworks/base/core/java/android/bluetooth/BluetoothAdapter.java
@@ -317,9 +317,6 @@ public final class BluetoothAdapter {
      */
     public static final int SCAN_MODE_CONNECTABLE_DISCOVERABLE = 23;
 
-    /** @hide */
-    public static final String ACTION_UUID_CHANGED=
-              "android.bluetooth.adapter.action.ACTION_UUID_CHANGED";
     /**
      * Broadcast Action: The local Bluetooth adapter has started the remote
      * device discovery process.
diff --git a/frameworks/base/core/java/android/bluetooth/IBluetoothA2dpSink.aidl b/frameworks/base/core/java/android/bluetooth/IBluetoothA2dpSink.aidl
index fe4ae3b..b7c6476 100644
--- a/frameworks/base/core/java/android/bluetooth/IBluetoothA2dpSink.aidl
+++ b/frameworks/base/core/java/android/bluetooth/IBluetoothA2dpSink.aidl
@@ -31,6 +31,4 @@ interface IBluetoothA2dpSink {
     List<BluetoothDevice> getDevicesMatchingConnectionStates(in int[] states);
     int getConnectionState(in BluetoothDevice device);
     BluetoothAudioConfig getAudioConfig(in BluetoothDevice device);
-    boolean setPriority(in BluetoothDevice device, int priority);
-    int getPriority(in BluetoothDevice device);
 }
diff --git a/frameworks/base/media/java/android/media/AudioAttributes.java b/frameworks/base/media/java/android/media/AudioAttributes.java
index a1f5427..02ffa77 100644
--- a/frameworks/base/media/java/android/media/AudioAttributes.java
+++ b/frameworks/base/media/java/android/media/AudioAttributes.java
@@ -557,8 +557,7 @@ public final class AudioAttributes implements Parcelable {
         public Builder setInternalCapturePreset(int preset) {
             if ((preset == MediaRecorder.AudioSource.HOTWORD)
                     || (preset == MediaRecorder.AudioSource.REMOTE_SUBMIX)
-                    || (preset == MediaRecorder.AudioSource.RADIO_TUNER)
-                    || (preset == MediaRecorder.AudioSource.BLUETOOTH_A2DP)) {
+                    || (preset == MediaRecorder.AudioSource.RADIO_TUNER)) {
                 mSource = preset;
             } else {
                 setCapturePreset(preset);
diff --git a/frameworks/base/media/java/android/media/AudioManager.java b/frameworks/base/media/java/android/media/AudioManager.java
index d7aa7db..875e716 100644
--- a/frameworks/base/media/java/android/media/AudioManager.java
+++ b/frameworks/base/media/java/android/media/AudioManager.java
@@ -1506,11 +1506,8 @@ public class AudioManager {
      *         false if otherwise
      */
     public boolean isBluetoothA2dpOn() {
-        if ((AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP,"")
-            == AudioSystem.DEVICE_STATE_UNAVAILABLE) ||
-            (AudioSystem.getDeviceConnectionState(DEVICE_IN_BLUETOOTH_A2DP,"")
-            == AudioSystem.DEVICE_STATE_UNAVAILABLE))
-        {
+        if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP,"")
+            == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
             return false;
         } else {
             return true;
@@ -2906,16 +2903,10 @@ public class AudioManager {
     /** @hide
      * The audio output device code for generic Bluetooth A2DP, for music */
     public static final int DEVICE_OUT_BLUETOOTH_A2DP = AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP;
-
-    /** @hide
-     * The audio input device code for generic Bluetooth A2DP, for music */
-    public static final int DEVICE_IN_BLUETOOTH_A2DP = AudioSystem.DEVICE_IN_BLUETOOTH_A2DP;
-
     /** @hide
      * The audio output device code for Bluetooth A2DP headphones, for music */
     public static final int DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES =
             AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
-
     /** @hide
      * The audio output device code for Bluetooth A2DP external speaker, for music */
     public static final int DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER =
diff --git a/frameworks/base/media/java/android/media/MediaRecorder.java b/frameworks/base/media/java/android/media/MediaRecorder.java
index 4823e42..ed2c4cb 100644
--- a/frameworks/base/media/java/android/media/MediaRecorder.java
+++ b/frameworks/base/media/java/android/media/MediaRecorder.java
@@ -252,13 +252,6 @@ public class MediaRecorder
         public static final int REMOTE_SUBMIX = 8;
 
         /**
-        * @hide
-        *A2DP audio.
-        */
-        public static final int BLUETOOTH_A2DP = 9;
-
-
-        /**
          * Audio source for capturing broadcast radio tuner output.
          * @hide
          */
@@ -412,7 +405,7 @@ public class MediaRecorder
      * @see android.media.MediaRecorder.AudioSource
      */
     public static final int getAudioSourceMax() {
-        return AudioSource.BLUETOOTH_A2DP;
+        return AudioSource.REMOTE_SUBMIX;
     }
 
     /**
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java
index e772db0..9608daa 100755
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpProfile.java
@@ -33,7 +33,7 @@ import java.util.List;
 
 public final class A2dpProfile implements LocalBluetoothProfile {
     private static final String TAG = "A2dpProfile";
-    private static boolean V = true;
+    private static boolean V = false;
 
     private BluetoothA2dp mService;
     private boolean mIsProfileReady;
@@ -46,11 +46,6 @@ public final class A2dpProfile implements LocalBluetoothProfile {
         BluetoothUuid.AdvAudioDist,
     };
 
-	static final ParcelUuid[] SOURCE_UUIDS = {
-        BluetoothUuid.AudioSource,
-        BluetoothUuid.AdvAudioDist,
-    };
-
     static final String NAME = "A2DP";
     private final LocalBluetoothProfileManager mProfileManager;
 
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpSinkProfile.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpSinkProfile.java
deleted file mode 100644
index 667691a..0000000
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/A2dpSinkProfile.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2013 Broadcom Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.android.settingslib.bluetooth;
-
-import android.bluetooth.BluetoothA2dpSink;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothClass;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothProfile;
-import android.bluetooth.BluetoothUuid;
-import android.content.Context;
-import android.os.ParcelUuid;
-import android.util.Log;
-
-import com.android.settingslib.R;
-
-
-import java.util.ArrayList;
-import java.util.List;
-
-
-final class A2dpSinkProfile implements LocalBluetoothProfile {
-    private static final String TAG = "A2dpSinkProfile";
-    private static boolean V = true;
-
-    private BluetoothA2dpSink mService;
-    private boolean mIsProfileReady;
-
-    private final LocalBluetoothAdapter mLocalAdapter;
-    private final CachedBluetoothDeviceManager mDeviceManager;
-
-    static final ParcelUuid[] SINK_UUIDS = {
-        BluetoothUuid.AudioSink,
-        BluetoothUuid.AdvAudioDist,
-    };
-
-    static final ParcelUuid[] SOURCE_UUIDS = {
-        BluetoothUuid.AudioSource,
-        BluetoothUuid.AdvAudioDist,
-    };
-
-
-    static final String NAME = "A2DPSink";
-    private final LocalBluetoothProfileManager mProfileManager;
-
-    // Order of this profile in device profiles list
-    private static final int ORDINAL = 1;
-
-    // These callbacks run on the main thread.
-    private final class A2dpServiceListener
-            implements BluetoothProfile.ServiceListener {
-
-        public void onServiceConnected(int profile, BluetoothProfile proxy) {
-            if (V) Log.d(TAG,"Bluetooth service connected");
-            mService = (BluetoothA2dpSink) proxy;
-            // We just bound to the service, so refresh the UI for any connected A2DP devices.
-            List<BluetoothDevice> deviceList = mService.getConnectedDevices();
-            while (!deviceList.isEmpty()) {
-                BluetoothDevice nextDevice = deviceList.remove(0);
-                CachedBluetoothDevice device = mDeviceManager.findDevice(nextDevice);
-                // we may add a new device here, but generally this should not happen
-                if (device == null) {
-                    Log.w(TAG, "A2dpSinkProfile found new device: " + nextDevice);
-                    device = mDeviceManager.addDevice(mLocalAdapter, mProfileManager, nextDevice);
-                }
-                device.onProfileStateChanged(A2dpSinkProfile.this, BluetoothProfile.STATE_CONNECTED);
-                device.refresh();
-            }
-            mIsProfileReady=true;
-        }
-
-        public void onServiceDisconnected(int profile) {
-            if (V) Log.d(TAG,"Bluetooth service disconnected");
-            mIsProfileReady=false;
-        }
-    }
-
-    public boolean isProfileReady() {
-        return mIsProfileReady;
-    }
-
-    A2dpSinkProfile(Context context, LocalBluetoothAdapter adapter,
-            CachedBluetoothDeviceManager deviceManager,
-            LocalBluetoothProfileManager profileManager) {
-        mLocalAdapter = adapter;
-        mDeviceManager = deviceManager;
-        mProfileManager = profileManager;
-        mLocalAdapter.getProfileProxy(context, new A2dpServiceListener(),
-                BluetoothProfile.A2DP_SINK);
-    }
-
-    public boolean isConnectable() {
-        return true;
-    }
-
-    public boolean isAutoConnectable() {
-        return true;
-    }
-
-    public List<BluetoothDevice> getConnectedDevices() {
-        if (mService == null) return new ArrayList<BluetoothDevice>(0);
-        return mService.getDevicesMatchingConnectionStates(
-              new int[] {BluetoothProfile.STATE_CONNECTED,
-                         BluetoothProfile.STATE_CONNECTING,
-                         BluetoothProfile.STATE_DISCONNECTING});
-    }
-
-    public List<BluetoothDevice> getRcConnectedDevices() {
-        // REVIEW : TAG  intergrate with RC
-        /*if (mService == null) return new ArrayList<BluetoothDevice>(0);
-        return mService.getDevicesMatchingConnectionStates(
-              new int[] {BluetoothConstants.AVRC_STATE_CONNECTED});*/
-
-        return null;
-    }
-
-    public boolean connect(BluetoothDevice device) {
-        if (mService == null) return false;
-        List<BluetoothDevice> sinks = getConnectedDevices();
-        if (sinks != null) {
-            for (BluetoothDevice sink : sinks) {
-                // If the device is already connected dont disconnect
-                // In some cases the System UI app initiates connection before Settings app
-                if (! device.equals(sink))
-                    mService.disconnect(sink);
-            }
-        }
-        return mService.connect(device);
-    }
-
-    public boolean disconnect(BluetoothDevice device) {
-        if (mService == null) return false;
-        // Downgrade priority as user is disconnecting the headset.
-        if (mService.getPriority(device) > BluetoothProfile.PRIORITY_ON){
-            mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
-        }
-        return mService.disconnect(device);
-    }
-
-    public int getConnectionStatus(BluetoothDevice device) {
-        if (mService == null) {
-            return BluetoothProfile.STATE_DISCONNECTED;
-        }
-        return mService.getConnectionState(device);
-    }
-
-    public boolean isPreferred(BluetoothDevice device) {
-        if (mService == null) return false;
-        return mService.getPriority(device) > BluetoothProfile.PRIORITY_OFF;
-    }
-
-    public int getPreferred(BluetoothDevice device) {
-        if (mService == null) return BluetoothProfile.PRIORITY_OFF;
-        return mService.getPriority(device);
-    }
-
-    public void setPreferred(BluetoothDevice device, boolean preferred) {
-        if (mService == null) return;
-        if (preferred) {
-            if (mService.getPriority(device) < BluetoothProfile.PRIORITY_ON) {
-                mService.setPriority(device, BluetoothProfile.PRIORITY_ON);
-            }
-        } else {
-            mService.setPriority(device, BluetoothProfile.PRIORITY_OFF);
-        }
-    }
-
-    public String toString() {
-        return NAME;
-    }
-
-    public int getOrdinal() {
-        return ORDINAL;
-    }
-
-    public int getNameResource(BluetoothDevice device) {
-        return R.string.bluetooth_profile_a2dp;
-    }
-
-    public int getSummaryResourceForDevice(BluetoothDevice device) {
-        int state = getConnectionStatus(device);
-        switch (state) {
-            case BluetoothProfile.STATE_DISCONNECTED:
-                return R.string.bluetooth_a2dp_profile_summary_use_for;
-
-            case BluetoothProfile.STATE_CONNECTED:
-                return R.string.bluetooth_a2dp_profile_summary_connected;
-
-            default:
-                return Utils.getConnectionStateSummary(state);
-        }
-    }
-
-    public int getDrawableResource(BluetoothClass btClass) {
-        return R.drawable.ic_bt_headphones_a2dp;
-    }
-
-    protected void finalize() {
-        if (V) Log.d(TAG, "finalize()");
-        if (mService != null) {
-            try {
-                BluetoothAdapter.getDefaultAdapter().closeProfileProxy(BluetoothProfile.A2DP_SINK,
-                                                                       mService);
-                mService = null;
-            }catch (Throwable t) {
-                Log.w(TAG, "Error cleaning up A2DP Sink proxy", t);
-            }
-        }
-    }
-}
-
-
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothDeviceFilter.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothDeviceFilter.java
index 7809f00..8dec86a 100644
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothDeviceFilter.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothDeviceFilter.java
@@ -112,9 +112,6 @@ public final class BluetoothDeviceFilter {
                 if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SINK_UUIDS)) {
                     return true;
                 }
-				if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SOURCE_UUIDS)) {
-                    return true;
-                }
                 if (BluetoothUuid.containsAnyUuid(uuids, HeadsetProfile.UUIDS)) {
                     return true;
                 }
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
index ef5b17b..4bcbea7 100755
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/BluetoothEventManager.java
@@ -32,7 +32,6 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
-import java.util.List;
 
 /**
  * BluetoothEventManager receives broadcasts and callbacks from the Bluetooth
@@ -68,9 +67,6 @@ public final class BluetoothEventManager {
         mProfileIntentFilter.addAction(action);
     }
 
-    void removeProfileHandler(String action) {
-        mHandlerMap.remove(action);
-    }
     // Set profile manager after construction due to circular dependency
     void setProfileManager(LocalBluetoothProfileManager manager) {
         mProfileManager = manager;
@@ -110,9 +106,6 @@ public final class BluetoothEventManager {
         // Dock event broadcasts
         addHandler(Intent.ACTION_DOCK_EVENT, new DockEventHandler());
 
-        // Handle local and remote UUid changed on device mode switch
-        addHandler(BluetoothAdapter.ACTION_UUID_CHANGED,
-             new LocalRemoteUuidChanged());
         mContext.registerReceiver(mBroadcastReceiver, mAdapterIntentFilter, null, mReceiverHandler);
     }
 
@@ -261,15 +254,6 @@ public final class BluetoothEventManager {
             mDeviceManager.onDeviceNameUpdated(device);
         }
     }
-    /*ACTION_UUID_CHANGED intent is received here Local and remote profile
-       uuids are updated*/
-    private class LocalRemoteUuidChanged implements Handler {
-        public void onReceive(Context context, Intent intent,
-                BluetoothDevice device) {
-            Log.d(TAG,"LocalRemoteUuidChanged");
-            mDeviceManager.updateLocalandRemoteProfiles();
-        }
-    }
 
     private class BondStateChangedHandler implements Handler {
         public void onReceive(Context context, Intent intent,
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java
index a0794fa..d994841 100644
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDevice.java
@@ -171,7 +171,6 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
 
     public void disconnect() {
         for (LocalBluetoothProfile profile : mProfiles) {
-			Log.d(TAG, "disconnect profile = "+profile);
             disconnect(profile);
         }
         // Disconnect  PBAP server in case its connected
@@ -182,19 +181,6 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
         {
             PbapProfile.disconnect(mDevice);
         }
-        // Disconnect A2dp service for devices where only RC is connected without A2DP
-        A2dpProfile a2dpProfile = mProfileManager.getA2dpProfile();
-        if (a2dpProfile != null) {
-			Log.d(TAG, "disconnect a2dpProfile device = "+mDevice);
-            //a2dpProfile.disconnect(mDevice);
-        }
-		A2dpSinkProfile a2dpSinkProfile = mProfileManager.getA2dpSinkProfile();
-		if (a2dpSinkProfile != null) {
-			Log.d(TAG, "disconnect a2dpSinkProfile device = "+mDevice);
-            //a2dpSinkProfile.disconnect(mDevice);
-		}
-
-        // REIVEW: TAG RC Target handling for AV sink ?
     }
 
     public void disconnect(LocalBluetoothProfile profile) {
@@ -494,7 +480,7 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
         mBtClass = mDevice.getBluetoothClass();
     }
 
-    public synchronized boolean updateProfiles() {
+    private boolean updateProfiles() {
         ParcelUuid[] uuids = mDevice.getUuids();
         if (uuids == null) return false;
 
@@ -553,10 +539,10 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
          * Otherwise, allow the connect on UUID change.
          */
         if (!mProfiles.isEmpty()
-                && ((mConnectAttempted + timeout) > SystemClock.elapsedRealtime()
-                || (mConnectAttempted == 0))) {
+                && ((mConnectAttempted + timeout) > SystemClock.elapsedRealtime())) {
             connectWithoutResettingTimer(false);
         }
+
         dispatchAttributesChanged();
     }
 
@@ -822,7 +808,12 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
             // The pairing dialog now warns of phone-book access for paired devices.
             // No separate prompt is displayed after pairing.
             if (getPhonebookPermissionChoice() == CachedBluetoothDevice.ACCESS_UNKNOWN) {
-                setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
+                if (mDevice.getBluetoothClass().getDeviceClass()
+                        == BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE) {
+                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_ALLOWED);
+                } else {
+                    setPhonebookPermissionChoice(CachedBluetoothDevice.ACCESS_REJECTED);
+                }
             }
         }
     }
@@ -860,8 +851,7 @@ public final class CachedBluetoothDevice implements Comparable<CachedBluetoothDe
 
                 case BluetoothProfile.STATE_DISCONNECTED:
                     if (profile.isProfileReady()) {
-                        if (profile instanceof A2dpProfile ||
-                                (profile instanceof A2dpSinkProfile)) {
+                        if (profile instanceof A2dpProfile) {
                             a2dpNotConnected = true;
                         } else if (profile instanceof HeadsetProfile) {
                             headsetNotConnected = true;
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDeviceManager.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDeviceManager.java
index 99f9f81..a9f4bd3 100755
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDeviceManager.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/CachedBluetoothDeviceManager.java
@@ -25,7 +25,6 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import android.os.ParcelUuid;
 /**
  * CachedBluetoothDeviceManager manages the set of remote Bluetooth devices.
  */
@@ -34,16 +33,13 @@ public final class CachedBluetoothDeviceManager {
     private static final boolean DEBUG = Utils.D;
 
     private Context mContext;
-    private LocalBluetoothAdapter mLocalAdapter;
     private final List<CachedBluetoothDevice> mCachedDevices =
             new ArrayList<CachedBluetoothDevice>();
     private final LocalBluetoothManager mBtManager;
 
-    CachedBluetoothDeviceManager(Context context, LocalBluetoothManager localBtManager,
-LocalBluetoothAdapter localAdapter) {
+    CachedBluetoothDeviceManager(Context context, LocalBluetoothManager localBtManager) {
         mContext = context;
         mBtManager = localBtManager;
-        mLocalAdapter = localAdapter;
     }
 
     public synchronized Collection<CachedBluetoothDevice> getCachedDevicesCopy() {
@@ -61,31 +57,6 @@ LocalBluetoothAdapter localAdapter) {
             cachedDevice.refreshName();
         }
     }
-    //After the  device mode switch the local UUID list is updated with
-    //profiles added or removed based on DEFAULT_MODE or HEADSET_MODE
-
-    public void updateLocalandRemoteProfiles() {
-        ParcelUuid[] localUuids = mLocalAdapter.getUuids();
-
-        if (null != localUuids) {
-            mBtManager.getProfileManager().updateLocalProfiles(localUuids);
-	        for (int i=0; i<localUuids.length; i++) {
-	        	Log.d(TAG, "updateLocalandRemoteProfiles, localUuids="+localUuids[i]);
-	        }
-        }
-        for (int i = mCachedDevices.size() - 1; i >= 0; i--) {
-            mCachedDevices.get(i).updateProfiles();
-            mCachedDevices.get(i).refresh();
-        }
-    }
-
-    public void updateRemoteProfiles() {
-        Log.d(TAG, "updateRemoteProfiles");
-        for (int i = mCachedDevices.size() - 1; i >= 0; i--) {
-            mCachedDevices.get(i).updateProfiles();
-            mCachedDevices.get(i).refresh();
-        }
-    }
 
     /**
      * Search for existing {@link CachedBluetoothDevice} or return null
@@ -196,10 +167,6 @@ LocalBluetoothAdapter localAdapter) {
             }
         }
     }
-    public synchronized boolean onDeviceRemoved(CachedBluetoothDevice cachedDevice) {
-        cachedDevice.setVisible(false);
-        return mCachedDevices.remove(cachedDevice);
-    }
     private void log(String msg) {
         if (DEBUG) {
             Log.d(TAG, msg);
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothManager.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothManager.java
index 110b41c..623ccc3 100644
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothManager.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothManager.java
@@ -68,7 +68,7 @@ public final class LocalBluetoothManager {
         mContext = context;
         mLocalAdapter = adapter;
 
-        mCachedDeviceManager = new CachedBluetoothDeviceManager(context, this, adapter);
+        mCachedDeviceManager = new CachedBluetoothDeviceManager(context, this);
         mEventManager = new BluetoothEventManager(mLocalAdapter,
                 mCachedDeviceManager, context);
         mProfileManager = new LocalBluetoothProfileManager(context,
diff --git a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java
index bf163b4..8f5e1f1 100644
--- a/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java
+++ b/frameworks/base/packages/SettingsLib/src/com/android/settingslib/bluetooth/LocalBluetoothProfileManager.java
@@ -17,7 +17,6 @@
 package com.android.settingslib.bluetooth;
 
 import android.bluetooth.BluetoothA2dp;
-import android.bluetooth.BluetoothA2dpSink;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothHeadset;
 import android.bluetooth.BluetoothMap;
@@ -40,7 +39,7 @@ import java.util.Map;
  */
 public final class LocalBluetoothProfileManager {
     private static final String TAG = "LocalBluetoothProfileManager";
-    private static final boolean DEBUG = true;//Utils.D;
+    private static final boolean DEBUG = Utils.D;
     /** Singleton instance. */
     private static LocalBluetoothProfileManager sInstance;
 
@@ -74,7 +73,6 @@ public final class LocalBluetoothProfileManager {
     private final BluetoothEventManager mEventManager;
 
     private A2dpProfile mA2dpProfile;
-    private A2dpSinkProfile mA2dpSinkProfile;
     private HeadsetProfile mHeadsetProfile;
     private MapProfile mMapProfile;
     private final HidProfile mHidProfile;
@@ -148,25 +146,8 @@ public final class LocalBluetoothProfileManager {
             }
         } else if (mA2dpProfile != null) {
             Log.w(TAG, "Warning: A2DP profile was previously added but the UUID is now missing.");
-            removeProfile(mA2dpProfile, A2dpProfile.NAME,
-                BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
-            mA2dpProfile =  null;
         }
 
-        // AV sink Device
-        if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSink)) {
-            if (mA2dpSinkProfile == null) {
-                if(DEBUG) Log.d(TAG, "Adding local A2DP Sink profile");
-                mA2dpSinkProfile = new A2dpSinkProfile(mContext, mLocalAdapter, mDeviceManager, this);
-                addProfile(mA2dpSinkProfile, A2dpSinkProfile.NAME,
-                        BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
-            }
-        } else if (mA2dpSinkProfile != null) {
-            Log.w(TAG, "Warning: A2DP Sink profile was previously added but the UUID is now missing.");
-            removeProfile(mA2dpSinkProfile, A2dpSinkProfile.NAME,
-                BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
-            mA2dpSinkProfile =  null;
-        }
         // Headset / Handsfree
         if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.Handsfree_AG) ||
             BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.HSP_AG)) {
@@ -178,11 +159,6 @@ public final class LocalBluetoothProfileManager {
                         BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
             }
         } else if (mHeadsetProfile != null) {
-            removeProfile(mHeadsetProfile, HeadsetProfile.NAME,
-                    BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
-            //Close the old headset proxy
-            mHeadsetProfile.finalize();
-            mHeadsetProfile =  null;
             Log.w(TAG, "Warning: HEADSET profile was previously added but the UUID is now missing.");
         }
 
@@ -211,11 +187,6 @@ public final class LocalBluetoothProfileManager {
         mProfileNameMap.put(profileName, profile);
     }
 
-    private void removeProfile(LocalBluetoothProfile profile,
-            String profileName, String stateChangedAction) {
-        mEventManager.removeProfileHandler(stateChangedAction);
-        mProfileNameMap.remove(profileName);
-    }
     private void addPanProfile(LocalBluetoothProfile profile,
             String profileName, String stateChangedAction) {
         mEventManager.addProfileHandler(stateChangedAction,
@@ -324,9 +295,6 @@ public final class LocalBluetoothProfileManager {
         return mA2dpProfile;
     }
 
-    A2dpSinkProfile getA2dpSinkProfile() {
-        return mA2dpSinkProfile;
-    }
     public HeadsetProfile getHeadsetProfile() {
         return mHeadsetProfile;
     }
@@ -377,15 +345,6 @@ public final class LocalBluetoothProfileManager {
             removedProfiles.remove(mA2dpProfile);
         }
 
-		if (BluetoothUuid.containsAnyUuid(uuids, A2dpProfile.SOURCE_UUIDS) &&
-            mA2dpSinkProfile != null) {
-            if (DEBUG) Log.d(TAG, "updateProfiles add profie sink");
-            profiles.add(mA2dpSinkProfile);
-            removedProfiles.remove(mA2dpSinkProfile);
-        }else {
-        	if (DEBUG) Log.d(TAG, "updateProfiles mA2dpSinkProfile="+mA2dpSinkProfile);
-        }
-
         if (BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.ObexObjectPush) &&
             mOppProfile != null) {
             profiles.add(mOppProfile);
diff --git a/packages/apps/Bluetooth/AndroidManifest.xml b/packages/apps/Bluetooth/AndroidManifest.xml
index 27f2f30..3652fd3 100644
--- a/packages/apps/Bluetooth/AndroidManifest.xml
+++ b/packages/apps/Bluetooth/AndroidManifest.xml
@@ -17,7 +17,6 @@
         android:description="@string/permdesc_bluetoothWhitelist"
         android:protectionLevel="signature" />
 
-    <uses-permission android:name="android.permission.RECORD_AUDIO" />
     <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
     <uses-permission android:name="android.permission.ACCESS_BLUETOOTH_SHARE" />
     <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
@@ -63,7 +62,6 @@
     <uses-permission android:name="android.permission.VIBRATE" />
     <uses-permission android:name="android.permission.DEVICE_POWER" />
     <uses-permission android:name="android.permission.REAL_GET_TASKS" />
-    <uses-permission android:name="android.permission.MODIFY_AUDIO_ROUTING" />
 
     <!-- For PBAP Owner Vcard Info -->
     <uses-permission android:name="android.permission.READ_PROFILE"/>
@@ -340,11 +338,5 @@
                 <action android:name="android.bluetooth.IBluetoothHeadsetClient" />
             </intent-filter>
         </service>
-	<activity android:name="com.broadcom.bt.settings.BluetoothAdvancedSettings"
-            android:process="@string/process"
-            android:label="@string/bt_advanced_settings"
-            android:excludeFromRecents="true"
-            android:enabled="@bool/supports_advanced_settings">
-        </activity>
     </application>
 </manifest>
diff --git a/packages/apps/Bluetooth/jni/com_android_bluetooth_hfpclient.cpp b/packages/apps/Bluetooth/jni/com_android_bluetooth_hfpclient.cpp
index bc3bb5a..62133eb 100644
--- a/packages/apps/Bluetooth/jni/com_android_bluetooth_hfpclient.cpp
+++ b/packages/apps/Bluetooth/jni/com_android_bluetooth_hfpclient.cpp
@@ -573,13 +573,10 @@ static jboolean sendATCmdNative(JNIEnv *env, jobject object, jint cmd,
     bt_status_t status;
     const char *arg = NULL;
 
-    if (!sBluetoothHfpClientInterface)
-         return JNI_FALSE;
+    if (!sBluetoothHfpClientInterface) return JNI_FALSE;
 
     if (arg_str != NULL) {
         arg = env->GetStringUTFChars(arg_str, NULL);
-        if(arg == NULL)
-            return JNI_FALSE;
     }
 
     if ((status = sBluetoothHfpClientInterface->send_at_cmd(cmd,val1,val2,arg)) !=
@@ -587,7 +584,7 @@ static jboolean sendATCmdNative(JNIEnv *env, jobject object, jint cmd,
         ALOGE("Failed to send cmd, status: %d", status);
     }
 
-    if (arg_str != NULL) {
+    if (arg != NULL) {
         env->ReleaseStringUTFChars(arg_str, arg);
     }
     return (status == BT_STATUS_SUCCESS) ? JNI_TRUE : JNI_FALSE;
diff --git a/packages/apps/Bluetooth/res/layout/preference_header_item.xml b/packages/apps/Bluetooth/res/layout/preference_header_item.xml
deleted file mode 100644
index 9f8222b..0000000
--- a/packages/apps/Bluetooth/res/layout/preference_header_item.xml
+++ /dev/null
@@ -1,97 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2012-2013 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-<!-- Layout of a header item in PreferenceActivity. -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:background="?android:attr/activatedBackgroundIndicator"
-    android:gravity="center_vertical"
-    android:paddingRight="?android:attr/scrollbarSize">
-
-    <LinearLayout
-        android:id="@+id/image_layout"
-        android:visibility="gone"
-        android:layout_width="@dimen/header_icon_width"
-        android:layout_marginLeft="6dip"
-        android:layout_marginRight="6dip"
-        android:layout_height="wrap_content">
-        <ImageView
-            android:id="@+id/icon"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center" />
-    </LinearLayout>
-
-    <RelativeLayout
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginLeft="2dip"
-        android:layout_marginRight="6dip"
-        android:layout_marginTop="6dip"
-        android:layout_marginBottom="6dip"
-        android:layout_weight="1">
-
-        <TextView android:id="@+android:id/title"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:singleLine="true"
-            android:textAppearance="?android:attr/textAppearanceMedium"
-            android:ellipsize="marquee"
-            android:fadingEdge="horizontal" />
-
-        <TextView android:id="@+android:id/summary"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_below="@android:id/title"
-            android:layout_alignLeft="@android:id/title"
-            android:textAppearance="?android:attr/textAppearanceSmall"
-            android:ellipsize="end"
-            android:maxLines="2" />
-
-    </RelativeLayout>
-
-</LinearLayout>
diff --git a/packages/apps/Bluetooth/res/layout/preference_header_mode_switch_item.xml b/packages/apps/Bluetooth/res/layout/preference_header_mode_switch_item.xml
deleted file mode 100644
index 0e1f802..0000000
--- a/packages/apps/Bluetooth/res/layout/preference_header_mode_switch_item.xml
+++ /dev/null
@@ -1,105 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2012-2013 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-<!-- Layout of a header item in PreferenceActivity. -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:background="?android:attr/activatedBackgroundIndicator"
-    android:gravity="center_vertical"
-    android:paddingEnd="?android:attr/scrollbarSize">
-
-    <LinearLayout
-        android:layout_width="@dimen/header_icon_width"
-        android:layout_marginStart="6dip"
-        android:layout_marginEnd="6dip"
-        android:layout_height="wrap_content">
-        <ImageView
-            android:id="@+id/icon"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center" />
-    </LinearLayout>
-
-    <RelativeLayout
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginStart="2dip"
-        android:layout_marginEnd="6dip"
-        android:layout_marginTop="6dip"
-        android:layout_marginBottom="6dip"
-        android:layout_weight="1">
-
-        <TextView android:id="@+android:id/title"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:singleLine="true"
-            android:textAppearance="?android:attr/textAppearanceMedium"
-            android:ellipsize="marquee"
-            android:fadingEdge="horizontal" />
-
-        <TextView android:id="@+android:id/summary"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_below="@android:id/title"
-            android:layout_alignStart="@android:id/title"
-            android:textAppearance="?android:attr/textAppearanceSmall"
-            android:ellipsize="end"
-            android:maxLines="2" />
-
-    </RelativeLayout>
-
-   <Switch android:id="@+id/switchWidget"
-       android:layout_width="wrap_content"
-       android:layout_height="wrap_content"
-       android:layout_gravity="center"
-       android:padding="8dip"
-       android:focusable="false"
-       android:clickable="true"
-       android:textOn="TV"
-       android:textOff="HeadSet" />
-
-</LinearLayout>
diff --git a/packages/apps/Bluetooth/res/layout/preference_header_switch_item.xml b/packages/apps/Bluetooth/res/layout/preference_header_switch_item.xml
deleted file mode 100644
index 4099316..0000000
--- a/packages/apps/Bluetooth/res/layout/preference_header_switch_item.xml
+++ /dev/null
@@ -1,105 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2012-2013 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-
-<!-- Layout of a header item in PreferenceActivity. -->
-<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
-    android:layout_width="match_parent"
-    android:layout_height="wrap_content"
-    android:minHeight="48dp"
-    android:background="?android:attr/activatedBackgroundIndicator"
-    android:gravity="center_vertical"
-    android:paddingRight="?android:attr/scrollbarSize">
-    <LinearLayout
-        android:id="@+id/image_layout"
-        android:visibility="gone"
-        android:layout_width="@dimen/header_icon_width"
-        android:layout_marginLeft="6dip"
-        android:layout_marginRight="6dip"
-        android:layout_height="wrap_content">
-        <ImageView
-            android:id="@+id/icon"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_gravity="center" />
-    </LinearLayout>
-
-    <RelativeLayout
-        android:layout_width="wrap_content"
-        android:layout_height="wrap_content"
-        android:layout_marginLeft="2dip"
-        android:layout_marginRight="6dip"
-        android:layout_marginTop="6dip"
-        android:layout_marginBottom="6dip"
-        android:layout_weight="1">
-
-        <TextView android:id="@+android:id/title"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:singleLine="true"
-            android:textAppearance="?android:attr/textAppearanceMedium"
-            android:ellipsize="marquee"
-            android:fadingEdge="horizontal" />
-
-        <TextView android:id="@+android:id/summary"
-            android:layout_width="wrap_content"
-            android:layout_height="wrap_content"
-            android:layout_below="@android:id/title"
-            android:layout_alignLeft="@android:id/title"
-            android:textAppearance="?android:attr/textAppearanceSmall"
-            android:ellipsize="end"
-            android:maxLines="2" />
-
-    </RelativeLayout>
-
-   <Switch android:id="@+id/switchWidget"
-       android:layout_width="wrap_content"
-       android:layout_height="wrap_content"
-       android:layout_gravity="center"
-       android:padding="8dip"
-       android:focusable="false"
-       android:clickable="true" />
-
-</LinearLayout>
diff --git a/packages/apps/Bluetooth/res/values/config.xml b/packages/apps/Bluetooth/res/values/config.xml
index 0651185..1684183 100644
--- a/packages/apps/Bluetooth/res/values/config.xml
+++ b/packages/apps/Bluetooth/res/values/config.xml
@@ -14,9 +14,9 @@
 -->
 <resources>
     <bool name="profile_supported_a2dp">true</bool>
-    <bool name="profile_supported_a2dp_sink">true</bool>
+    <bool name="profile_supported_a2dp_sink">false</bool>
     <bool name="profile_supported_hdp">true</bool>
-    <bool name="profile_supported_hs_hfp">false</bool>
+    <bool name="profile_supported_hs_hfp">true</bool>
     <bool name="profile_supported_hfpclient">false</bool>
     <bool name="profile_supported_hid">true</bool>
     <bool name="profile_supported_opp">true</bool>
diff --git a/packages/apps/Bluetooth/res/values/config_bt.xml b/packages/apps/Bluetooth/res/values/config_bt.xml
deleted file mode 100644
index 7372716..0000000
--- a/packages/apps/Bluetooth/res/values/config_bt.xml
+++ /dev/null
@@ -1,153 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2012-2013 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-<resources>
-
-    <!-- Supports advanced settings configuration by user -->
-    <bool name="supports_advanced_settings">true</bool>
-
-
-    <bool name="supports_device_mode_cfg">true</bool>
-
-
-    <!-- Standard Profiles. Enable/disable from config.xml -->
-    <!--Refer ProfileConfig.java for configuring profile_cfg_run_in_device_mode_-->
-    <bool name="profile_default_start_hs_hfp">false</bool>
-    <bool name="profile_configurable_hs_hfp">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hs_hfp">2</integer>
-    <bool name="profile_default_start_a2dp">true</bool>
-    <bool name="profile_default_start_a2dp_sink">false</bool>
-    <bool name="profile_configurable_a2dp">false</bool>
-    <bool name="profile_configurable_a2dp_sink">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_a2dp">2</integer>
-    <integer name="profile_cfg_run_in_device_mode_a2dp_sink">1</integer>
-    <bool name="profile_default_start_hid">true</bool>
-    <bool name="profile_configurable_hid">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hid">0</integer>
-    <bool name="profile_default_start_hdp">true</bool>
-    <bool name="profile_configurable_hdp">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hdp">0</integer>
-    <bool name="profile_default_start_pan">false</bool>
-    <bool name="profile_configurable_pan">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_pan">0</integer>
-    <bool name="profile_default_start_mse">false</bool>
-    <bool name="profile_configurable_mse">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_mse">0</integer>
-
-    <bool name="profile_configurable_hfclient">false</bool>
-    <bool name="profile_default_start_hfclient">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hfclient">0</integer>
-    <!-- Broadcom Profiles -->
-    <bool name="profile_default_start_3d_sync">true</bool>
-    <bool name="profile_configurable_3d_sync">false</bool>
-    <bool name="run_in_quiet_mode_3d_sync">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_3d_sync">0</integer>
-    
-    <!-- Gatt Profile -->
-    <bool name="profile_default_start_gatt">true</bool>
-    <bool name="profile_configurable_gatt">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_gatt">0</integer>
-
-    <!-- Opp Profile  -->
-    <bool name="profile_supported_opp_1_2_service">true</bool>
-    <bool name="profile_default_start_opp_service">true</bool>
-    <bool name="profile_configurable_opp_service">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_opp">0</integer>
-
-
-    <!-- FTP Profile -->
-    <bool name="profile_supported_ftp_server">false</bool>
-    <bool name="profile_default_start_ftp_server">false</bool>
-    <bool name="profile_configurable_ftp_server">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_ftp_server">0</integer>
-
-    <!-- SAP Profile -->
-    <bool name="profile_default_start_sap">false</bool>
-    <bool name="profile_configurable_sap">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_sap">0</integer>
-
-    <!-- MAP MSE Profile -->
-    <bool name="mse_datasource_supported_sms">false</bool>
-    <bool name="mse_datasource_supported_mms">false</bool>
-    <string name="profile_map_version">MAP 1.2</string>
-
-    <!-- DUN Profile -->
-    <bool name="profile_supported_dun">false</bool>
-    <bool name="profile_default_start_dun">false</bool>
-    <bool name="profile_configurable_dun">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_dun">0</integer>
-
-    <!-- HID Device Profile -->
-    <bool name="profile_supported_hidd">false</bool>
-    <bool name="profile_default_start_hidd">false</bool>
-    <bool name="profile_configurable_hidd">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hidd">0</integer>
-
-    <!-- AVRCP Controller Profile -->
-    <bool name="profile_default_start_avrcp_ct">true</bool>
-    <bool name="profile_configurable_avrcp_ct">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_avrcp_ct">0</integer>
-
-    <!-- MAP MCE Profile -->
-    <bool name="profile_supported_mce">false</bool>
-    <bool name="profile_default_start_mce">false</bool>
-    <bool name="profile_configurable_mce">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_mce">0</integer>
-
-    <bool name="tv_mode">true</bool>
-
-    <!-- HF device Profile -->
-    <bool name="profile_supported_hfdevice">false</bool>
-    <bool name="profile_default_start_hfdevice">false</bool>
-    <bool name="profile_configurable_hfdevice">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_hfdevice">1</integer>
-
-    <!-- IPSP Profile -->
-    <bool name="profile_supported_ipsp">false</bool>
-    <bool name="profile_default_start_ipsp">false</bool>
-    <bool name="profile_configurable_ipsp">false</bool>
-    <integer name="profile_cfg_run_in_device_mode_ipsp">0</integer>
-
-</resources>
diff --git a/packages/apps/Bluetooth/res/values/dimens_bt.xml b/packages/apps/Bluetooth/res/values/dimens_bt.xml
deleted file mode 100644
index 2ad3fe0..0000000
--- a/packages/apps/Bluetooth/res/values/dimens_bt.xml
+++ /dev/null
@@ -1,54 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2015 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-
-<resources>
-
-
-    <!--  Size of icons in the top-level of settings  -->
-    <dimen name="header_icon_width">28dp</dimen>
-    <dimen name="appwidget_min_width">260dip</dimen>
-    <dimen name="appwidget_min_height">40dip</dimen>
-</resources>
diff --git a/packages/apps/Bluetooth/res/values/strings_bt.xml b/packages/apps/Bluetooth/res/values/strings_bt.xml
deleted file mode 100644
index c6a9530..0000000
--- a/packages/apps/Bluetooth/res/values/strings_bt.xml
+++ /dev/null
@@ -1,108 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<!--
-   Copyright (C) 2015 Broadcom Corporation
-
-   This program is the proprietary software of Broadcom Corporation and/or its
-   licensors, and may only be used, duplicated, modified or distributed
-   pursuant to the terms and conditions of a separate, written license
-   agreement executed between you and Broadcom (an "Authorized License").
-   Except as set forth in an Authorized License, Broadcom grants no license
-   (express or implied), right to use, or waiver of any kind with respect to
-   the Software, and Broadcom expressly reserves all rights in and to the
-   Software and all intellectual property rights therein.
-   IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
-   SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
-   ALL USE OF THE SOFTWARE.
-
-   Except as expressly set forth in the Authorized License,
-
-   1.     This program, including its structure, sequence and organization,
-          constitutes the valuable trade secrets of Broadcom, and you shall
-          use all reasonable efforts to protect the confidentiality thereof,
-          and to use this information only in connection with your use of
-          Broadcom integrated circuit products.
-
-   2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
-          "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
-          REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
-          OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
-          DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
-          NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
-          ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
-          CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
-          OF USE OR PERFORMANCE OF THE SOFTWARE.
-
-   3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
-          ITS LICENSORS BE LIABLE FOR
-          (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
-                DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
-                YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
-                HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
-          (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
-                SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
-                LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
-                ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
--->
-<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-
-    <string name="permlab_bluetoothMap">Access Bluetooth Message Access Profile content provider.</string>
-    <string name="permdesc_bluetoothMap">Allows the app to access the Bluetooth Message Access Profile content provider and use it send messages to MAP messages to clients.</string>
-    <string name="permlab_fm_receiver">access FM receiver</string>
-    <string name="permdesc_fm_receiver">Allows an application to access the FM receiver functions.</string>
-    <string name="bt_advanced_settings">Bluetooth Advanced Settings</string>
-    <string name="profile_hs_hfp">HS/HFP</string>
-    <string name="profile_description_hs_hfp">Headset/Handsfree Profile</string>
-    <string name="profile_a2dp">A2DP</string>
-    <string name="profile_a2dp_sink">A2DP_SINK</string>
-    <string name="profile_description_a2dp_sink">A2DP Profile Sink</string>
-    <string name="profile_description_a2dp">A2DP Profile</string>
-    <string name="profile_hid">HID Host</string>
-    <string name="profile_description_hid">Human Interface Device (Host) Profile</string>
-    <string name="profile_hdp">HDP</string>
-    <string name="profile_description_hdp">Health Devices Profile</string>
-    <string name="profile_pan">PAN</string>
-    <string name="profile_description_pan">Personal Area Network Profile</string>
-    <string name="profile_dun">DUN</string>
-    <string name="profile_description_dun">Dial Up Network Profile</string>
-    <string name="profile_gatt">GATT</string>
-    <string name="profile_description_gatt">GATT/BLE Profile</string>
-    <string name="profile_sap">SAP</string>
-    <string name="profile_description_sap">SIM Access Profile</string>
-    <string name="profile_ftp">FTP</string>
-    <string name="profile_description_ftp">File Transfer (Server) Profile</string>
-    <string name="profile_mse">MAP</string>
-    <string name="profile_description_mse">Message Access Profile</string>
-    <string name="title_bt_mse_settings">Bluetooth MAP Advanced Settings</string>
-    <string name="map_provider_smsmms_name">Messaging</string>
-    <string name="map_datasource_sms_name">SMS</string>
-    <string name="map_datasource_mms_name">MMS</string>
-    <string name="map_datasource_smsmms_name">SMS and MMS</string>
-    <string name="profile_hidd">HID Device</string>
-    <string name="profile_description_hidd">Human Interface Device (Device) Profile</string>
-    <string name="profile_avrcp_ct">AVRCP Controller</string>
-    <string name="profile_description_avrcp_ct">AVRCP Controller Profile</string>
-    <string name="profile_hfdevice">HF Device</string>
-    <string name="profile_hfclient">HF Client</string>
-    <string name="profile_description_hfdevice">HFP-HF</string>
-    <string name="profile_mce">MAP MCE</string>
-    <string name="profile_description_mce">Message Access Profile (Client)</string>
-    <string name="title_bt_mce_settings">MAP Client Advanced Settings</string>
-    <string name="profile_ipsp">IPSP Profile</string>
-    <string name="profile_description_ipsp">IPSP Profile</string>
-    <!-- For Selecting the Active Modes -->
-    <string name="active_mode">Phone Device Mode</string>
-    <string name="TV_mode">TV_mode</string>
-    <string name="Headset_mode">Headset_mode</string>
-    <string name="bt_toast_conn">Connection not allowed in this mode
-    </string>
-    <string name="profile_3d_sync">3D Glass</string>
-    <string name="profile_description_3d_sync">3D Glass Profile</string>
-    <!--Enabling and disabling of OPP service -->
-    <string name="profile_opp">OPP</string>
-    <string name="profile_description_opp">Object Push Profile</string>
-    <!-- newly added string for OPP 1.2 implementation -->
-    <string name="status_no_permission">no permission.</string>
-    <string name="status_srv_unavailable">Service unavailable.</string>
-    <string name="status_opc_not_found">response not found.</string>
-
-</resources>
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
index 6ecaa4e..e14302c 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpService.java
@@ -32,17 +32,13 @@ import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import android.os.SystemClock;
-
-import android.content.Intent;
-import android.bluetooth.BluetoothA2dp;
 
 /**
  * Provides Bluetooth A2DP profile, as a service in the Bluetooth application.
  * @hide
  */
 public class A2dpService extends ProfileService {
-    private static final boolean DBG = true;
+    private static final boolean DBG = false;
     private static final String TAG="A2dpService";
 
     private A2dpStateMachine mStateMachine;
@@ -65,22 +61,13 @@ public class A2dpService extends ProfileService {
     }
 
     protected boolean start() {
-		Intent intent = new Intent(BluetoothA2dp.ACTION_A2DP_FORCE_BIND);
-		intent.putExtra(BluetoothProfile.EXTRA_STATE, "true");
-		
-		mStateMachine = A2dpStateMachine.make(this, this);
         mAvrcp = Avrcp.make(this);
+        mStateMachine = A2dpStateMachine.make(this, this);
         setA2dpService(this);
-
-		this.sendBroadcast(intent);
         return true;
     }
 
     protected boolean stop() {
-		Intent intent = new Intent(BluetoothA2dp.ACTION_A2DP_FORCE_BIND);
-		intent.putExtra(BluetoothProfile.EXTRA_STATE, "false");
-		this.sendBroadcast(intent);
-		
         if (mStateMachine != null) {
             mStateMachine.doQuit();
         }
@@ -162,7 +149,7 @@ public class A2dpService extends ProfileService {
         return true;
     }
 
-    public boolean disconnect(BluetoothDevice device) {
+    boolean disconnect(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -177,13 +164,10 @@ public class A2dpService extends ProfileService {
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-		while (mStateMachine == null) {
-			SystemClock.sleep(15);
-		}
         return mStateMachine.getConnectedDevices();
     }
 
-    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
@@ -209,7 +193,6 @@ public class A2dpService extends ProfileService {
         int priority = Settings.Global.getInt(getContentResolver(),
             Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
             BluetoothProfile.PRIORITY_UNDEFINED);
-		if (DBG) Log.d(TAG, "getPriority " + device + " = " + priority);
         return priority;
     }
 
@@ -256,7 +239,6 @@ public class A2dpService extends ProfileService {
 
         BluetoothA2dpBinder(A2dpService svc) {
             mService = svc;
-			if (DBG) Log.d(TAG, "BluetoothA2dpBinder svc=" + svc);
         }
 
         public boolean cleanup()  {
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkService.java
index 1809274..5dcec73 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkService.java
@@ -20,7 +20,6 @@ import android.bluetooth.BluetoothAudioConfig;
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.IBluetoothA2dpSink;
-import android.provider.Settings;
 import android.util.Log;
 import com.android.bluetooth.btservice.ProfileService;
 import com.android.bluetooth.Utils;
@@ -28,14 +27,12 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-import android.content.Intent;
-import android.bluetooth.BluetoothA2dpSink;
 /**
  * Provides Bluetooth A2DP Sink profile, as a service in the Bluetooth application.
  * @hide
  */
 public class A2dpSinkService extends ProfileService {
-    private static final boolean DBG = true;
+    private static final boolean DBG = false;
     private static final String TAG = "A2dpSinkService";
 
     private A2dpSinkStateMachine mStateMachine;
@@ -50,24 +47,13 @@ public class A2dpSinkService extends ProfileService {
     }
 
     protected boolean start() {
-		Intent intent = new Intent(BluetoothA2dpSink.ACTION_A2DP_SINK_FORCE_BIND);
-		intent.putExtra(BluetoothProfile.EXTRA_STATE, "true");
-
         mStateMachine = A2dpSinkStateMachine.make(this, this);
         setA2dpSinkService(this);
-		
-		this.sendBroadcast(intent);
         return true;
     }
 
     protected boolean stop() {
-		Intent intent = new Intent(BluetoothA2dpSink.ACTION_A2DP_SINK_FORCE_BIND);
-		intent.putExtra(BluetoothProfile.EXTRA_STATE, "false");
-		this.sendBroadcast(intent);
-		
-        if (mStateMachine!= null) {
-			mStateMachine.doQuit();
-        }
+        mStateMachine.doQuit();
         return true;
     }
 
@@ -129,7 +115,7 @@ public class A2dpSinkService extends ProfileService {
         return true;
     }
 
-    public boolean disconnect(BluetoothDevice device) {
+    boolean disconnect(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -144,11 +130,10 @@ public class A2dpSinkService extends ProfileService {
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-        if (mStateMachine == null) return new ArrayList<BluetoothDevice>(0);
         return mStateMachine.getConnectedDevices();
     }
 
-    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
@@ -163,25 +148,6 @@ public class A2dpSinkService extends ProfileService {
         return mStateMachine.getAudioConfig(device);
     }
 
-    public boolean setPriority(BluetoothDevice device, int priority) {
-        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
-                                       "Need BLUETOOTH_ADMIN permission");
-        Settings.Global.putInt(getContentResolver(),
-            Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
-            priority);
-        if (DBG) Log.d(TAG,"Saved priority " + device + " = " + priority);
-        return true;
-    }
-
-    public int getPriority(BluetoothDevice device) {
-        enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
-                                       "Need BLUETOOTH_ADMIN permission");
-        int priority = Settings.Global.getInt(getContentResolver(),
-            Settings.Global.getBluetoothA2dpSinkPriorityKey(device.getAddress()),
-            BluetoothProfile.PRIORITY_UNDEFINED);
-		if (DBG) Log.d(TAG, "getPriority " + device + " = " + priority);
-        return priority;
-    }
     //Binder object: Must be static class or memory leak may occur
     private static class BluetoothA2dpSinkBinder extends IBluetoothA2dpSink.Stub
         implements IProfileServiceBinder {
@@ -201,7 +167,6 @@ public class A2dpSinkService extends ProfileService {
 
         BluetoothA2dpSinkBinder(A2dpSinkService svc) {
             mService = svc;
-			if (DBG) Log.d(TAG, "BluetoothA2dpSinkBinder svc=" + svc);
         }
 
         public boolean cleanup()  {
@@ -244,17 +209,6 @@ public class A2dpSinkService extends ProfileService {
             if (service == null) return null;
             return service.getAudioConfig(device);
         }
-        public boolean setPriority(BluetoothDevice device, int priority) {
-            A2dpSinkService service = getService();
-            if (service == null) return false;
-            return service.setPriority(device, priority);
-        }
-
-        public int getPriority(BluetoothDevice device) {
-            A2dpSinkService service = getService();
-            if (service == null) return BluetoothProfile.PRIORITY_UNDEFINED;
-            return service.getPriority(device);
-        }
     };
 
     @Override
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
index 1ee943d..d57a0ca 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpSinkStateMachine.java
@@ -60,18 +60,8 @@ import java.util.List;
 import java.util.HashMap;
 import java.util.Set;
 
-import android.util.Log;
-
-import android.bluetooth.BluetoothAudioConfig;
-import android.media.AudioDevicePort;
-import android.media.AudioManager;
-import android.media.AudioPatch;
-import android.media.AudioPort;
-import android.media.AudioPortConfig;
-import android.media.AudioSystem;
 final class A2dpSinkStateMachine extends StateMachine {
-    private static final boolean DBG = true;
-    private static final String TAG = "A2dpSinkStateMachine";
+    private static final boolean DBG = false;
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
@@ -117,18 +107,6 @@ final class A2dpSinkStateMachine extends StateMachine {
     private BluetoothDevice mTargetDevice = null;
     private BluetoothDevice mIncomingDevice = null;
 
-    private BluetoothAudioConfig mAudioConfig;
-
-    private AudioDevicePort mA2dpSinkPort;
-    private AudioDevicePort mA2dpOutputPort;
-
-    private AudioDevicePort mSpeakerPort;
-    private AudioDevicePort mHeadsetPort;
-    private AudioDevicePort mHeadphonePort;
-    private AudioPatch mAudioPatch;
-    private boolean mA2dpRoutingEnabled;
-
-    private final Object mAudioPatchLock = new Object();
     private final HashMap<BluetoothDevice,BluetoothAudioConfig> mAudioConfigs
             = new HashMap<BluetoothDevice,BluetoothAudioConfig>();
 
@@ -160,153 +138,8 @@ final class A2dpSinkStateMachine extends StateMachine {
         mIntentBroadcastHandler = new IntentBroadcastHandler();
 
         mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
-        Log.d(TAG, "Registering audio port listener");
-        mAudioManager.registerAudioPortUpdateListener(mAudioPortUpdateListener);
-
-        mA2dpRoutingEnabled = false;
-    }
-    // Aquires port based on below priority order
-    private AudioDevicePort aquirePreferredOutputPort()
-    {
-        Log.d(TAG, "aquirePreferredOutputPort");
-
-        // First attempt headset port
-        if (mHeadsetPort != null)
-        {
-            Log.d(TAG, "route to headset port " + mHeadsetPort);
-            return mHeadsetPort;
-        }
-
-        // If not available, attempt headphone port
-        if (mHeadphonePort != null)
-        {
-            Log.d(TAG, "route to headphone port " + mHeadphonePort);
-            return mHeadphonePort;
-        }
-
-        // If not available, attempt speaker port
-        if (mSpeakerPort != null)
-        {
-            Log.d(TAG, "route to speaker port " + mSpeakerPort);
-            return mSpeakerPort;
-        }
-
-        Log.d(TAG, "no output ports available");
-        return null;
-    }
-
-    private synchronized void updateA2dpRouting() {
-
-        synchronized(mAudioPatchLock)
-        {
-           AudioDevicePort outPort = aquirePreferredOutputPort();
-
-           boolean ready = (mA2dpSinkPort != null && mAudioConfig != null && outPort != null);
-           boolean active = (mAudioPatch != null);
-           boolean update = false;
-
-           if (mA2dpOutputPort != null)
-               update = !mA2dpOutputPort.equals(outPort);
-
-           Log.d(TAG, "updateA2dpRouting ready: " + ready + ", active: " + active +
-                      " routing enabled: " + mA2dpRoutingEnabled + " update " + update);
-
-           if (update && (mAudioPatch != null))
-           {
-               Log.d(TAG, "update patch ! cur " + mAudioPatch + " outport " + outPort
-                + " updateA2dpRouting " + mA2dpOutputPort);
-               mAudioManager.releaseAudioPatch(mAudioPatch);
-               mAudioPatch = null;
-               ready = true;
-           }
-
-           if (!ready || mA2dpRoutingEnabled == active) {
-               Log.d(TAG, "updateA2dpRouting: nothing to do, mA2dpSinkPort="
-			   	+mA2dpSinkPort+" mAudioConfig="+mAudioConfig+" outPort="+outPort);
-               return;
-           }
-
-           if (mA2dpRoutingEnabled) {
-               Log.d(TAG, "Creating patch mA2dpSinkPort " + mA2dpSinkPort + " outPort " + outPort);
-               int sampleRate = mAudioConfig.getSampleRate();
-               int channelMask = mAudioConfig.getChannelConfig();
-               int format = mAudioConfig.getAudioFormat();
-               AudioPortConfig sourceConfig = mA2dpSinkPort.buildConfig(sampleRate, channelMask,
-                format, null);
-               AudioPortConfig sinkConfig = outPort.buildConfig(sampleRate, channelMask, format,
-                null);
-               AudioPortConfig[] sources = { sourceConfig };
-               AudioPortConfig[] sinks = { sinkConfig };
-               AudioPatch[] patches = { null };
-
-               int result = mAudioManager.createAudioPatch(patches, sources, sinks);
-               mAudioPatch = patches[0];
-               mA2dpOutputPort = outPort;
-
-               Log.d(TAG, "createAudioPatch returned " + result + " patch: " + mAudioPatch);
-           } else {
-               if (mAudioPatch != null) {
-                   Log.d(TAG, "release audio patch");
-                   mAudioManager.releaseAudioPatch(mAudioPatch);
-                   mAudioPatch = null;
-               }
-           }
-        }
     }
 
-    private final AudioManager.OnAudioPortUpdateListener mAudioPortUpdateListener =
-		new AudioManager.OnAudioPortUpdateListener() {
-
-        public void onAudioPortListUpdate(AudioPort[] portList) {
-
-            synchronized(mAudioPatchLock)
-            {
-                Log.d(TAG, "onAudioPortListUpdate()");
-                mSpeakerPort = null;
-                mHeadsetPort = null;
-                mHeadphonePort = null;
-                mA2dpSinkPort = null;
-
-                for (int i = 0; i < portList.length; i++) {
-                    AudioPort port = portList[i];
-                    if (port instanceof AudioDevicePort) {
-                        AudioDevicePort aport = (AudioDevicePort)port;
-                        Log.d(TAG, "AudioDevicePort[" + i + "]: " + aport);
-                        if (aport.type() == AudioSystem.DEVICE_OUT_SPEAKER) {
-                            Log.d(TAG, "DEVICE_OUT_SPEAKER available");
-                            mSpeakerPort = aport;
-                        } else if (aport.type() == AudioSystem.DEVICE_OUT_WIRED_HEADSET) {
-                            Log.d(TAG, "DEVICE_OUT_WIRED_HEADSET available");
-                            mHeadsetPort = aport;
-                        } else if (aport.type() == AudioSystem.DEVICE_OUT_WIRED_HEADPHONE) {
-                            Log.d(TAG, "DEVICE_OUT_WIRED_HEADPHONE available");
-                            mHeadphonePort = aport;
-                        } else if (aport.type() == AudioSystem.DEVICE_IN_BLUETOOTH_A2DP) {
-                            Log.d(TAG, "DEVICE_IN_BLUETOOTH_A2DP available");
-                            mA2dpSinkPort = aport;
-                        }
-                    } else {
-                        Log.d(TAG, "PORT[" + i + "]: " + port);
-                    }
-                }
-            }
-            updateA2dpRouting();
-        }
-
-        public void onAudioPatchListUpdate(AudioPatch[] patchList) {
-
-            Log.d(TAG, "onAudioPatchListUpdate()");
-            for (int i = 0; i < patchList.length; i++) {
-                Log.d(TAG, "PATCH[" + i + "]: " + patchList[i]);
-            }
-            updateA2dpRouting();
-        }
-
-        public void onServiceDied() {
-            Log.d(TAG, "onServiceDied()");
-        }
-    };
-
     static A2dpSinkStateMachine make(A2dpSinkService svc, Context context) {
         Log.d("A2dpSinkStateMachine", "make");
         A2dpSinkStateMachine a2dpSm = new A2dpSinkStateMachine(svc, context);
@@ -315,12 +148,10 @@ final class A2dpSinkStateMachine extends StateMachine {
     }
 
     public void doQuit() {
-		if (DBG) Log.d(TAG, "doQuit");
         quitNow();
     }
 
     public void cleanup() {
-        mAudioManager.unregisterAudioPortUpdateListener(mAudioPortUpdateListener);
         cleanupNative();
         mAudioConfigs.clear();
     }
@@ -336,7 +167,6 @@ final class A2dpSinkStateMachine extends StateMachine {
         @Override
         public void enter() {
             log("Enter Disconnected: " + getCurrentMessage().what);
-            mA2dpRoutingEnabled = false;
         }
 
         @Override
@@ -645,8 +475,8 @@ final class A2dpSinkStateMachine extends StateMachine {
         public void enter() {
             log("Enter Connected: " + getCurrentMessage().what);
             // Upon connected, the audio starts out as stopped
-            //broadcastAudioState(mCurrentDevice, BluetoothA2dpSink.STATE_NOT_PLAYING,
-            //                    BluetoothA2dpSink.STATE_PLAYING);
+            broadcastAudioState(mCurrentDevice, BluetoothA2dpSink.STATE_NOT_PLAYING,
+                                BluetoothA2dpSink.STATE_PLAYING);
         }
 
         @Override
@@ -686,7 +516,6 @@ final class A2dpSinkStateMachine extends StateMachine {
                     if (!mCurrentDevice.equals(device)) {
                         break;
                     }
-                    processAudioStateEvent(AUDIO_STATE_STOPPED, device);
                     broadcastConnectionState(device, BluetoothProfile.STATE_DISCONNECTING,
                                    BluetoothProfile.STATE_CONNECTED);
                     if (!disconnectA2dpNative(getByteAddress(device))) {
@@ -724,8 +553,6 @@ final class A2dpSinkStateMachine extends StateMachine {
         private void processConnectionEvent(int state, BluetoothDevice device) {
             switch (state) {
                 case CONNECTION_STATE_DISCONNECTED:
-                     mA2dpRoutingEnabled = false;
-                     updateA2dpRouting();
                     mAudioConfigs.remove(device);
                     if (mCurrentDevice.equals(device)) {
                         broadcastConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED,
@@ -751,18 +578,11 @@ final class A2dpSinkStateMachine extends StateMachine {
             }
             switch (state) {
                 case AUDIO_STATE_STARTED:
-                    AdapterService adapterService = AdapterService.getAdapterService();
-                    mA2dpRoutingEnabled = true;
-                    updateA2dpRouting();
                     broadcastAudioState(device, BluetoothA2dpSink.STATE_PLAYING,
                                         BluetoothA2dpSink.STATE_NOT_PLAYING);
                     break;
                 case AUDIO_STATE_REMOTE_SUSPEND:
                 case AUDIO_STATE_STOPPED:
-					if (state==AUDIO_STATE_STOPPED) {
-	                    mA2dpRoutingEnabled = false;
-	                    updateA2dpRouting();
-					}
                     broadcastAudioState(device, BluetoothA2dpSink.STATE_NOT_PLAYING,
                                         BluetoothA2dpSink.STATE_PLAYING);
                     break;
@@ -775,7 +595,6 @@ final class A2dpSinkStateMachine extends StateMachine {
 
     private void processAudioConfigEvent(BluetoothAudioConfig audioConfig, BluetoothDevice device) {
         mAudioConfigs.put(device, audioConfig);
-        mAudioConfig = audioConfig;
         broadcastAudioConfig(device, audioConfig);
     }
 
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpStateMachine.java b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
index f6ff2ea..2f217d9 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/a2dp/A2dpStateMachine.java
@@ -58,7 +58,7 @@ import java.util.List;
 import java.util.Set;
 
 final class A2dpStateMachine extends StateMachine {
-    private static final boolean DBG = true;
+    private static final boolean DBG = false;
 
     static final int CONNECT = 1;
     static final int DISCONNECT = 2;
@@ -144,6 +144,12 @@ final class A2dpStateMachine extends StateMachine {
     }
 
     public void doQuit() {
+        if ((mPlayingA2dpDevice != null) &&
+            (getConnectionState(mPlayingA2dpDevice) != BluetoothProfile.STATE_DISCONNECTED)) {
+            log("doQuit()- Disconnect A2DP Playing Device");
+            broadcastConnectionState(mPlayingA2dpDevice, BluetoothProfile.STATE_DISCONNECTED,
+                                     getConnectionState(mPlayingA2dpDevice));
+        }
         if ((mTargetDevice != null) &&
             (getConnectionState(mTargetDevice) == BluetoothProfile.STATE_CONNECTING)) {
             log("doQuit()- Move A2DP State to DISCONNECTED");
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterApp.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterApp.java
index 9542213..b7b988a 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterApp.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterApp.java
@@ -20,7 +20,6 @@
 
 package com.android.bluetooth.btservice;
 
-import com.broadcom.bt.service.ProfileConfig;
 import android.app.Application;
 import android.util.Log;
 
@@ -49,9 +48,7 @@ public class AdapterApp extends Application {
     public void onCreate() {
         super.onCreate();
         if (DBG) Log.d(TAG, "onCreate");
-        //Broadcom Enhancement
-        //Config.init(this);
-        ProfileConfig.init(this);
+        Config.init(this);
     }
 
     @Override
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java
index 9f57964..f7721b3 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterService.java
@@ -39,7 +39,6 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.SharedPreferences;
-import android.media.AudioManager;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.Handler;
@@ -54,16 +53,11 @@ import android.os.RemoteException;
 import android.os.SystemClock;
 import android.provider.Settings;
 import android.util.EventLog;
-import android.content.SharedPreferences;
-import android.content.res.Resources;
-import android.preference.PreferenceManager;
 import android.util.Log;
 import android.util.Pair;
 
 import com.android.bluetooth.a2dp.A2dpService;
-import com.android.bluetooth.a2dp.A2dpSinkService;
 import com.android.bluetooth.hid.HidService;
-import com.android.bluetooth.hfp.HeadsetHalConstants;
 import com.android.bluetooth.hfp.HeadsetService;
 import com.android.bluetooth.hdp.HealthService;
 import com.android.bluetooth.pan.PanService;
@@ -71,8 +65,7 @@ import com.android.bluetooth.sdp.SdpManager;
 import com.android.internal.R;
 import com.android.bluetooth.Utils;
 import com.android.bluetooth.btservice.RemoteDevices.DeviceProperties;
-import com.broadcom.bt.service.IProfileStateChangeListener;
-import com.broadcom.bt.service.ProfileConfig;
+
 import java.io.FileDescriptor;
 import java.io.FileWriter;
 import java.io.IOException;
@@ -89,12 +82,11 @@ import android.os.ServiceManager;
 
 public class AdapterService extends Service {
     private static final String TAG = "BluetoothAdapterService";
-    private static final boolean DBG = true;
-    private static final boolean TRACE_REF = true;
+    private static final boolean DBG = false;
+    private static final boolean TRACE_REF = false;
     private static final int MIN_ADVT_INSTANCES_FOR_MA = 5;
     private static final int MIN_OFFLOADED_FILTERS = 10;
     private static final int MIN_OFFLOADED_SCAN_STORAGE_BYTES = 1024;
-    private AudioManager mAudioManager;
     //For Debugging only
     private static int sRefCount=0;
 
@@ -114,9 +106,6 @@ public class AdapterService extends Service {
     public static final int PROFILE_CONN_CONNECTED  = 1;
     public static final int PROFILE_CONN_REJECTED  = 2;
 
-    public static int DEFAULT_MODE  = 0;
-    public static int HEADSET_MODE  = 1;
-    private Context mContext;
     private static final String ACTION_ALARM_WAKEUP =
         "com.android.bluetooth.btservice.action.ALARM_WAKEUP";
 
@@ -236,11 +225,8 @@ public class AdapterService extends Service {
     private void processInitProfilePriorities (BluetoothDevice device, ParcelUuid[] uuids){
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
-        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
 
-		debugLog("processInitProfilePriorities device="+device+" UUID="+uuids);
-
         // Set profile priorities only for the profiles discovered on the remote device.
         // This avoids needless auto-connect attempts to profiles non-existent on the remote device
         if ((hidService != null) &&
@@ -264,19 +250,10 @@ public class AdapterService extends Service {
             (headsetService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED))){
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_ON);
         }
-		
-		if((a2dpSinkService != null) &&
-            ( BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AudioSource) ||
-                    BluetoothUuid.isUuidPresent(uuids, BluetoothUuid.AdvAudioDist)) &&
-            (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
-            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_ON);
-        }
     }
 
     private void processProfileStateChanged(BluetoothDevice device, int profileId, int newState, int prevState) {
-        if (((profileId == BluetoothProfile.A2DP) ||
-			(profileId == BluetoothProfile.A2DP_SINK) ||
-			(profileId == BluetoothProfile.HEADSET)) &&
+        if (((profileId == BluetoothProfile.A2DP) ||(profileId == BluetoothProfile.HEADSET)) &&
              (newState == BluetoothProfile.STATE_CONNECTED)){
             debugLog( "Profile connected. Schedule missing profile connection if any");
             connectOtherProfile(device, PROFILE_CONN_CONNECTED);
@@ -292,87 +269,6 @@ public class AdapterService extends Service {
         }
     }
 
-    //BRCM enhancement: advanced settings/ enable/disable profiles
-    IProfileStateChangeListener mProfileStateChangeListener;
-
-    /**
-     * Register a profile state change listener
-     * @param listener
-     */
-    public void setProfileStateChangeListener(IProfileStateChangeListener listener) {
-        synchronized (mProfileServicesState) {
-            mProfileStateChangeListener = listener;
-        }
-    }
-
-    public void unsetProfileStateChangeListener() {
-        synchronized (mProfileServicesState) {
-            mProfileStateChangeListener=null;
-        }
-    }
-    /**
-     * Returns true if the specified profile is started
-     * @param profileName
-     * @return
-     */
-    public boolean isProfileStarted(String profileName) {
-        synchronized (mProfileServicesState) {
-            Integer profileState = mProfileServicesState.get(profileName);
-            if (profileState == null) {
-                Log.w(TAG,"isProfileEnabled(): profile not found "
-                        + toNonNullString(profileName));
-                return false;
-            }
-            Log.w(TAG,"isProfileEnabled(): profile " + toNonNullString(profileName)
-                    + ", state= " + profileState);
-            return profileState == BluetoothAdapter.STATE_ON;
-        }
-    }
-
-    public static String toNonNullString(String s) {
-        return s == null ? "" : s;
-    }
-
-    /**
-     * Turn on/off a specified profile. Returns true of the request is valid.
-     * @param profileName
-     * @param setEnabled
-     * @return
-     */
-    public boolean setProfileState(String profileName, boolean setEnabled) {
-        synchronized (mProfileServicesState) {
-
-
-            Integer profileState = mProfileServicesState.get(profileName);
-            if (profileState == null) {
-                Log.w(TAG,"setProfileState(): profile not found "
-                        + toNonNullString(profileName));
-                mProfileServicesState.put(profileName,BluetoothAdapter.STATE_OFF);
-                profileState = BluetoothAdapter.STATE_OFF;
-            }
-            if (setEnabled && (profileState != BluetoothAdapter.STATE_OFF) ||
-                !setEnabled &&(profileState !=BluetoothAdapter.STATE_ON)) {
-                Log.w(TAG,"setProfileState(): error setting profile state: "
-                        + toNonNullString(profileName) + " to enabled=" +setEnabled
-                        +" Current state=" + profileState);
-                return false;
-            }
-            //Set the pending state
-            mProfileServicesState.put(profileName,setEnabled?
-                    BluetoothAdapter.STATE_TURNING_ON: BluetoothAdapter.STATE_TURNING_OFF);
-            Intent intent = new Intent();
-            intent.setClassName(this, profileName);
-            intent.putExtra(EXTRA_ACTION,ACTION_SERVICE_STATE_CHANGED);
-            intent.putExtra(BluetoothAdapter.EXTRA_STATE,setEnabled?
-                    BluetoothAdapter.STATE_ON:BluetoothAdapter.STATE_OFF);
-            Log.d(TAG,"setProfileState(): setting profile "
-                    + toNonNullString(profileName) +" to state = " + profileState);
-            startService(intent);
-
-            return true;
-        }
-    }
-    //BRCM enhancement: advanced settings
     public void addProfile(ProfileService profile) {
         synchronized (mProfiles) {
             mProfiles.add(profile);
@@ -405,16 +301,6 @@ public class AdapterService extends Service {
                 mProfileServicesState.put(serviceName,state);
                 doUpdate=true;
             }
-            //BRCM enhancement: advanced settings turn on/off profiles
-            //dispatch event
-            if (mProfileStateChangeListener != null) {
-                Message m = mHandler.obtainMessage(MESSAGE_UPDATE_PROFILE_STATE_LISTENER);
-                m.obj=serviceName;
-                m.arg1 = state;
-                m.arg2 = prevState;
-                mHandler.sendMessage(m);
-			}
-			//BRCM enhancement
         }
         debugLog("onProfileServiceStateChange() serviceName=" + serviceName
             + ", state=" + state +", doUpdate=" + doUpdate);
@@ -423,7 +309,6 @@ public class AdapterService extends Service {
             return;
         }
 
-        processDeviceModeSwitchProfileServiceState(serviceName,state);
         synchronized (mAdapterStateMachine) {
             isTurningOff = mAdapterStateMachine.isTurningOff();
             isTurningOn = mAdapterStateMachine.isTurningOn();
@@ -541,16 +426,10 @@ public class AdapterService extends Service {
 
     void BleOnProcessStart() {
         debugLog("BleOnProcessStart()");
-        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+        Class[] supportedProfileServices = Config.getSupportedProfiles();
+        //Initialize data objects
         for (int i=0; i < supportedProfileServices.length;i++) {
-            String profileName = supportedProfileServices[i].getName();
-            if (ProfileConfig.isProfileConfiguredEnabled(profileName)){
-                if (isProfileStarted(profileName) == false) {
-                    mProfileServicesState.put(profileName, BluetoothAdapter.STATE_OFF);
-				}
-            } else {
-                Log.w(TAG,"processStart(): profile not enabled: "  + profileName);
-            }
+            mProfileServicesState.put(supportedProfileServices[i].getName(),BluetoothAdapter.STATE_OFF);
         }
         mRemoteDevices = new RemoteDevices(this);
         mAdapterProperties.init(mRemoteDevices);
@@ -570,9 +449,7 @@ public class AdapterService extends Service {
     void startCoreServices()
     {
         debugLog("startCoreServices()");
-        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
-
-		checkAndSetDeviceModeProperty();
+        Class[] supportedProfileServices = Config.getSupportedProfiles();
 
         //Start profile services
         if (!mProfilesStarted && supportedProfileServices.length >0) {
@@ -584,42 +461,13 @@ public class AdapterService extends Service {
         }
     }
 
-    private void checkAndSetDeviceModeProperty() {
-
-         /* The last set device mode value before BT turn off is retrieved from
-         sharedpreference while BT turning on Set this property before
-         enabling BT AdapterService,JNI layer and BTIF layer use this
-         value as the default device mode*/
-         Context context = getApplicationContext();
-         SharedPreferences settings = PreferenceManager.
-             getDefaultSharedPreferences(context);
-
-         int deviceMode = settings.getInt("DEVICEMODE",-1);
-         mAdapterStateMachine.setDeviceMode(deviceMode);
-         Log.d(TAG,"deviceMode from shared preference   " + deviceMode );
-         if( deviceMode == -1 )
-         {
-             Resources r = context.getResources();
-             boolean isDevicemode = r
-                     .getBoolean(com.android.bluetooth.R.bool.tv_mode);
-             if( isDevicemode )
-                mAdapterStateMachine.setDeviceMode(DEFAULT_MODE);
-             else
-                mAdapterStateMachine.setDeviceMode(HEADSET_MODE);
-         }
-         Log.d(TAG,"AdapterState deviceMode" + deviceMode );
-
-    }
     void startBluetoothDisable() {
         mAdapterStateMachine.sendMessage(mAdapterStateMachine.obtainMessage(AdapterState.BEGIN_DISABLE));
     }
 
     boolean stopProfileServices() {
-        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
-        mAudioManager = (AudioManager)getApplicationContext().
-                        getSystemService(getApplicationContext().AUDIO_SERVICE);
+        Class[] supportedProfileServices = Config.getSupportedProfiles();
         if (mProfilesStarted && supportedProfileServices.length>0) {
-            mAudioManager.setParameters("A2dpSuspended=true");
             setProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_OFF);
             return true;
         }
@@ -630,7 +478,7 @@ public class AdapterService extends Service {
     boolean stopGattProfileService() {
         //TODO: can optimize this instead of looping around all supported profiles
         debugLog("stopGattProfileService()");
-        Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
+        Class[] supportedProfileServices = Config.getSupportedProfiles();
 
         setGattProfileServiceState(supportedProfileServices,BluetoothAdapter.STATE_OFF);
         return true;
@@ -732,12 +580,7 @@ public class AdapterService extends Service {
     private static final int MESSAGE_PROFILE_CONNECTION_STATE_CHANGED=20;
     private static final int MESSAGE_CONNECT_OTHER_PROFILES = 30;
     private static final int MESSAGE_PROFILE_INIT_PRIORITIES=40;
-    private static final int MESSAGE_SEND_UUID_CHANGED = 50;
-    public static final int MESSAGE_DELAY_FOR_SEND_UUID_CHANGED = 3000;
     private static final int CONNECT_OTHER_PROFILES_TIMEOUT= 6000;
-    private static final int CONNECT_OTHER_PROFILES_DEVICE_MODE_TIMEOUT= 8000;
-
-    private static final int MESSAGE_UPDATE_PROFILE_STATE_LISTENER= 10000;
 
     private final Handler mHandler = new Handler() {
         @Override
@@ -769,29 +612,7 @@ public class AdapterService extends Service {
                     debugLog( "handleMessage() - MESSAGE_CONNECT_OTHER_PROFILES");
                     processConnectOtherProfiles((BluetoothDevice) msg.obj,msg.arg1);
                 }
-				case MESSAGE_SEND_UUID_CHANGED: {
-                    debugLog( "handleMessage() - MESSAGE_SEND_UUID_CHANGED");
-                    Intent intent = new Intent(BluetoothAdapter.ACTION_UUID_CHANGED);
-                    sendBroadcast(intent, BLUETOOTH_PERM);
-                    // Whenever UUID change happens reinit profile priorities
-                    reInitProfilePriorities();
-                }
-                    break;
-                //Broadcom enhancement: advanced settings: profile on/off
-                case MESSAGE_UPDATE_PROFILE_STATE_LISTENER: {
-                    if (DBG) debugLog( "MESSAGE_UPDATE_PROFILE_STATE_LISTENER");
-                    try {
-                        IProfileStateChangeListener listener = mProfileStateChangeListener;
-                        if (listener != null) {
-                            listener.onProfileStateChanged((String)msg.obj,msg.arg1,msg.arg2);
-                        }
-                    } catch (Throwable t) {
-                        Log.e(TAG,
-                                "MESSAGE_UPDATE_PROFILE_STATE_LISTENER: error calling listener",t);
-                    }
-                }
                     break;
-                //Broadcom enhancement
             }
         }
     };
@@ -815,8 +636,6 @@ public class AdapterService extends Service {
             String serviceName = services[i].getName();
             String simpleName = services[i].getSimpleName();
 
-			debugLog("setGattProfileServiceState i="+i+" servicename="+serviceName+" simplename="+simpleName);
-			
             if (simpleName.equals("GattService")) {
                 Integer serviceState = mProfileServicesState.get(serviceName);
 
@@ -856,17 +675,12 @@ public class AdapterService extends Service {
             pendingState = BluetoothAdapter.STATE_TURNING_OFF;
         }
 
-        synchronized (mProfileServicesState) {
         for (int i=0; i <services.length;i++) {
             String serviceName = services[i].getName();
             String simpleName = services[i].getSimpleName();
 
             if (simpleName.equals("GattService")) continue;
 
-                if (ProfileConfig.isProfileConfiguredEnabled(serviceName) == false) {
-                    Log.w(TAG, "Profile supported, But not enabled " + serviceName);
-                    continue;
-                }
             Integer serviceState = mProfileServicesState.get(serviceName);
             if(serviceState != null && serviceState != expectedCurrentState) {
                 debugLog("setProfileServiceState() - Unable to "
@@ -886,7 +700,6 @@ public class AdapterService extends Service {
             intent.putExtra(BluetoothAdapter.EXTRA_STATE,state);
             startService(intent);
         }
-        }
     }
 
     private boolean isAvailable() {
@@ -1660,7 +1473,7 @@ public class AdapterService extends Service {
          if (isQuietModeEnabled() == false) {
              debugLog( "autoConnect() - Initiate auto connection on BT on...");
              autoConnectHeadset();
-             autoConnectA2dpSrcSink();
+             autoConnectA2dp();
          }
          else {
              debugLog( "autoConnect() - BT is in quiet mode. Not initiating auto connections");
@@ -1682,22 +1495,16 @@ public class AdapterService extends Service {
         }
     }
 
-     private void autoConnectA2dpSrcSink(){
+     private void autoConnectA2dp(){
         A2dpService a2dpSservice = A2dpService.getA2dpService();
-        A2dpSinkService a2dpSinkservice = A2dpSinkService.getA2dpSinkService();
         BluetoothDevice bondedDevices[] = getBondedDevices();
-        if ((bondedDevices == null) || ((a2dpSservice == null) && (a2dpSinkservice == null))) {
+        if ((bondedDevices == null) ||(a2dpSservice == null)) {
             return;
         }
         for (BluetoothDevice device : bondedDevices) {
-            if ((a2dpSservice != null) && 
-				(a2dpSservice.getPriority(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT)){
+            if (a2dpSservice.getPriority(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT ){
                 debugLog("autoConnectA2dp() - Connecting A2DP with " + device.toString());
                 a2dpSservice.connect(device);
-            }else if ((a2dpSinkservice != null) &&
-            	(a2dpSinkservice.getPriority(device) == BluetoothProfile.PRIORITY_AUTO_CONNECT)) {
-            	debugLog("autoConnectA2dp() - Connecting A2DP Sink with " + device.toString());
-                a2dpSinkservice.connect(device);
             }
         }
     }
@@ -1718,307 +1525,32 @@ public class AdapterService extends Service {
         }
         HeadsetService  hsService = HeadsetService.getHeadsetService();
         A2dpService a2dpService = A2dpService.getA2dpService();
-		A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
 
-		debugLog("processConnectOtherProfiles device=" + device.toString() + " state=" + firstProfileStatus);
         // if any of the profile service is  null, second profile connection not required
-        if ((hsService == null) || ((a2dpService == null ) && (a2dpSinkService == null ))){
+        if ((hsService == null) ||(a2dpService == null )){
             return;
         }
-        List<BluetoothDevice> a2dpConnDevList= null;
-        List<BluetoothDevice> a2dpSinkConnDevList= null;
-        List<BluetoothDevice> hfConnDevList = null;
+        List<BluetoothDevice> a2dpConnDevList= a2dpService.getConnectedDevices();
+        List<BluetoothDevice> hfConnDevList= hsService.getConnectedDevices();
         // Check if the device is in disconnected state and if so return
         // We ned to connect other profile only if one of the profile is still in connected state
         // This is required to avoide a race condition in which profiles would
         // automaticlly connect if the disconnection is initiated within 6 seconds of connection
         //First profile connection being rejected is an exception
-		if (null != hsService)
-            hfConnDevList= hsService.getConnectedDevices();
-
-        if (null != a2dpService)
-            a2dpConnDevList = a2dpService.getConnectedDevices();
-
-        if (null != a2dpSinkService)
-            a2dpSinkConnDevList = a2dpSinkService.getConnectedDevices();
-		
-        if(/*(hfConnDevList.isEmpty() && a2dpConnDevList.isEmpty() && a2dpSinkConnDevList.isEmpty())&&*/
+        if((hfConnDevList.isEmpty() && a2dpConnDevList.isEmpty())&&
             (PROFILE_CONN_CONNECTED  == firstProfileStatus)){
             return;
         }
-        if((hfConnDevList != null) && (hfConnDevList.isEmpty()) &&
+        if((hfConnDevList.isEmpty()) &&
             (hsService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
             hsService.connect(device);
         }
-		else if((a2dpSinkConnDevList != null) && a2dpSinkConnDevList.isEmpty() &&
-            (a2dpSinkService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)) {
-            a2dpSinkService.connect(device);
-        }
-        else if((a2dpConnDevList != null) && (a2dpConnDevList.isEmpty()) &&
+        else if((a2dpConnDevList.isEmpty()) &&
             (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_ON)){
             a2dpService.connect(device);
         }
     }
 
-      /**
-       * Return  the switched device mode.
-       * @param
-       * @return current device mode
-       */
-      public int getDeviceMode() {
-         Log.d(TAG,"getDeviceMode  deviceMode "+  mAdapterStateMachine.getDeviceMode());
-             return mAdapterStateMachine.getDeviceMode();
-      }
-
-      /**
-       * Switch the device mode TV mode and Headset Mode. Returns true of the request is valid.
-       * @param devicemode
-       * @return
-       */
-     public boolean setDeviceMode(int deviceMode) {
-         if (getState()!= BluetoothAdapter.STATE_ON){
-            return false;
-         }
-
-         Message msg = mAdapterStateMachine.
-             obtainMessage(AdapterState.USER_DEVICE_MODE_SWITCH);
-         msg.arg1 = deviceMode;
-         mAdapterStateMachine.sendMessage(msg);
-         return true;
-     }
-	  
-     public boolean setProfileStateForDeviceModeSwitch(int deviceMode, boolean enable) {
-         boolean profileStateSet = false;
-         if (DEFAULT_MODE == deviceMode) {
-             Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
-                 for (int i=0; i < supportedProfileServices.length;i++) {
-                     String profileName = supportedProfileServices[i].getName();
-                     if (ProfileConfig.isPhoneModeProfile(profileName)){
-                         ProfileConfig.saveProfileSetting(profileName, enable);
-                         setProfileState(profileName, enable);
-                         if (!profileStateSet)
-                             profileStateSet = true;
-                     } else {
-                         Log.w(TAG,"Profile not configured for Device Mode Cfg: "  + profileName);
-                     }
-                 }
-        } else if (HEADSET_MODE == deviceMode) {
-             Class[] supportedProfileServices = ProfileConfig.getSupportedProfiles();
-             for (int i=0; i < supportedProfileServices.length;i++) {
-                 String profileName = supportedProfileServices[i].getName();
-                 if (ProfileConfig.isDeviceModeProfile(profileName)){
-                         ProfileConfig.saveProfileSetting(profileName, enable);
-                         setProfileState(profileName, enable);
-                         if (!profileStateSet)
-                             profileStateSet = true;
-                 } else {
-                     Log.w(TAG,"Profile not configured for Device Mode Cfg: "  + profileName);
-                 }
-             }
-         }
-        return profileStateSet;
-     }
-
-     public void broadcastDeviceModeSwitchStatus () {
-         Log.d(TAG, "Send broadcastDeviceModeSwitchStatus");
-         sendUUIDChange(0);
-         try {
-             IProfileStateChangeListener listener = mProfileStateChangeListener;
-             if (listener != null) {
-                 listener.onDeviceModeSwitchComplete();
-             }
-         } catch (Throwable t) {
-             Log.e(TAG,
-                     "onDeviceModeSwitchComplete: error calling listener",t);
-         }
-     }
-
-     public void sendUUIDChange (int delay)
-    {
-         Log.d(TAG, "Send ACTION_UUID_CHANGED message posted");
-         mHandler.sendEmptyMessageDelayed (MESSAGE_SEND_UUID_CHANGED, delay);
-    }
-
-     public void reInitProfilePriorities() {
-         Log.d(TAG,"Initialize All profile priorities after Device Mode Switch");
-         BluetoothDevice bondedDevices[] = getBondedDevices();
-         if(bondedDevices != null) {
-             for (BluetoothDevice device : bondedDevices) {
-                 DeviceProperties deviceProp = mRemoteDevices.getDeviceProperties(device);
-				 Log.d(TAG, "reInitProfilePriorities bondeDevice="+device+" deviceProp="+deviceProp);
-                 initProfilePriorities(device, deviceProp.getUuids());
-             }
-         }
-     }
-     private void processDeviceModeSwitchProfileServiceState(String serviceName,
-                                                                 int state) {
-         boolean isDeviceModeSwitchTurningOff;
-         boolean isDeviceModeSwitchTurningOn;
-         int pendingDeviceModeState;
-         synchronized (mAdapterStateMachine) {
-             isDeviceModeSwitchTurningOff = mAdapterStateMachine.isDeviceModeSwitchTurningOff();
-             isDeviceModeSwitchTurningOn = mAdapterStateMachine.isDeviceModeSwitchTurningOn();
-             pendingDeviceModeState = mAdapterStateMachine.getPendingDeviceMode();
-         }
-
-         Log.d(TAG, "processDeviceModeSwitchProfileServiceState(): serviceName="
-                 + toNonNullString(serviceName) + ", state=" + state
-                 + ", DeviceMode isDeviceModeSwitchTurningOff=" + isDeviceModeSwitchTurningOff
-                 + ",DeviceMode isDeviceModeSwitchTurningOn=" + isDeviceModeSwitchTurningOn);
-
-         if (isDeviceModeSwitchTurningOff) {
-             //Check if all Device Switch Mode services are stopped if so, do cleanup
-             //if (DBG) Log.d(TAG,"Checking if all Device Switch Mode profiles are stopped...");
-             synchronized (mProfileServicesState) {
-                 Iterator<Map.Entry<String,Integer>> i = mProfileServicesState.entrySet().iterator();
-                 while (i.hasNext()) {
-                     Map.Entry<String,Integer> entry = i.next();
-                     boolean isDeviceSwitchModeProfile;
-
-                     if (HEADSET_MODE  == pendingDeviceModeState)
-                         isDeviceSwitchModeProfile =
-                                     ProfileConfig.isPhoneModeProfile(entry.getKey());
-                     else //if (DEFAULT_MODE == pendingDeviceModeState)
-                         isDeviceSwitchModeProfile =
-                                 ProfileConfig.isDeviceModeProfile(entry.getKey());
-
-                     if ((BluetoothAdapter.STATE_OFF != entry.getValue()) &&
-                                     isDeviceSwitchModeProfile) {
-                             Log.d(TAG, "DeviceSwitchModeProfile still running: " +
-                                     entry.getKey());
-                             return;
-         }
-     }
-             }
-             if (DBG) Log.d(TAG, "All DeviceSwitchModeProfile services stopped...");
-             mAdapterStateMachine.sendMessage
-                 (mAdapterStateMachine.obtainMessage(
-                 AdapterState.DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF));
-
-         } else if (isDeviceModeSwitchTurningOn) {
-             //Check if all Device Switch Mode services are started if so, update state
-             //if (DBG) Log.d(TAG,"Checking if all Device Switch Mode profiles are running...");
-             synchronized (mProfileServicesState) {
-                 Iterator<Map.Entry<String,Integer>> i =
-                         mProfileServicesState.entrySet().iterator();
-                 while (i.hasNext()) {
-                     Map.Entry<String,Integer> entry = i.next();
-                     boolean isDeviceSwitchModeProfile;
-
-                     if (HEADSET_MODE  == pendingDeviceModeState)
-                         isDeviceSwitchModeProfile =
-                                     ProfileConfig.isDeviceModeProfile(entry.getKey());
-                     else //if (DEFAULT_MODE == PendingDeviceModeState)
-                         isDeviceSwitchModeProfile =
-                                 ProfileConfig.isPhoneModeProfile(entry.getKey());
-
-                     if ((BluetoothAdapter.STATE_ON != entry.getValue()) &&
-                                 isDeviceSwitchModeProfile) {
-                         Log.d(TAG, "DeviceSwitchModeProfile still not running:" +
-                                 entry.getKey());
-                         return;
-                     }
-                 }
-             }
-             if (DBG) Log.d(TAG, "All DeviceSwitchModeProfile services started.");
-             mAdapterStateMachine.sendMessage
-                 (mAdapterStateMachine.obtainMessage(
-                 AdapterState.DEVICE_MODE_SWITCH_SERVICES_TURNED_ON));
-         }
-
-     }
-
-        /**
-         * device mode change should be attempted only after all the connected profiles are
-         * disconnected.
-         * @param
-         * @return
-         */
-     public synchronized void disconnectDeviceModeProfiles() {
-
-
-         A2dpService a2dpService = A2dpService.getA2dpService();
-         A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
-         HeadsetService  hsService = HeadsetService.getHeadsetService();
-
-         if ( null != a2dpService) {
-             List<BluetoothDevice> a2dpConnDevList= a2dpService.getConnectedDevices();
-             for(BluetoothDevice device:a2dpConnDevList) {
-               Log.d(TAG,"disconnectDeviceModeProfile() disconnecting a2dp device "
-                       +  device);
-                   a2dpService.disconnect(device);
-             }
-         }
-
-         if ( null != a2dpSinkService) {
-             List<BluetoothDevice> a2dpSinkConnDevList= a2dpSinkService.getConnectedDevices();
-             for(BluetoothDevice device:a2dpSinkConnDevList) {
-               Log.d(TAG,"disconnectDeviceModeProfile() disconnecting a2dp Sink device "
-                       +  device);
-                   a2dpSinkService.disconnect(device);
-             }
-         }
-
-         if ( null != hsService) {
-             List<BluetoothDevice> hfConnDevList= hsService.getConnectedDevices();
-             for(BluetoothDevice device:hfConnDevList) {
-               Log.d(TAG,"disconnectDeviceModeProfile() disconnecting Headeset AG "
-                       +  device);
-                 hsService.disconnect(device);
-             }
-         }
-
-     }
-
-      public synchronized boolean  isDeviceModeProfilesDisconnected (){
-
-
-          mAudioManager = (AudioManager)getApplicationContext().
-                          getSystemService(getApplicationContext().AUDIO_SERVICE);
-          A2dpService a2dpService = A2dpService.getA2dpService();
-          A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
-          HeadsetService hsService = HeadsetService.getHeadsetService();
-
-         if (a2dpService != null) {
-             List<BluetoothDevice> a2dpConnDevList= a2dpService.getDevicesMatchingConnectionStates(
-                    new int[] {BluetoothProfile.STATE_CONNECTED,
-                               BluetoothProfile.STATE_CONNECTING,
-                               BluetoothProfile.STATE_DISCONNECTING});
-             Log.d(TAG,"A2dp isempty = "+ a2dpConnDevList.isEmpty()+ " isBluetoothA2dpOn = "
-                 + mAudioManager.isBluetoothA2dpOn());
-             if(!a2dpConnDevList.isEmpty()
-                 || mAudioManager.isBluetoothA2dpOn())
-                 return false;
-         }
-
-         if (a2dpSinkService != null) {
-             List<BluetoothDevice> a2dpSinkConnDevList= a2dpSinkService.getDevicesMatchingConnectionStates(
-                    new int[] {BluetoothProfile.STATE_CONNECTED,
-                               BluetoothProfile.STATE_CONNECTING,
-                               BluetoothProfile.STATE_DISCONNECTING});
-             Log.d(TAG,"A2dp Sink isempty = "+ a2dpSinkConnDevList.isEmpty()+ " isBluetoothA2dpOn = "
-                 + mAudioManager.isBluetoothA2dpOn());
-             if(!a2dpSinkConnDevList.isEmpty()
-                 || mAudioManager.isBluetoothA2dpOn())
-                 return false;
-         }
-
-         if (hsService != null){
-             List<BluetoothDevice> hfConnDevList= hsService.getDevicesMatchingConnectionStates(
-                    new int[] {BluetoothProfile.STATE_CONNECTED,
-                               BluetoothProfile.STATE_CONNECTING,
-                               BluetoothProfile.STATE_DISCONNECTING});
-             Log.d(TAG,"HS isempty = "+ hfConnDevList.isEmpty());
-
-             if(!hfConnDevList.isEmpty())
-                 return false;
-         }
-
-
-         return true;
-
-     }
-
      private void adjustOtherHeadsetPriorities(HeadsetService  hsService,
                                                     List<BluetoothDevice> connectedDeviceList) {
         for (BluetoothDevice device : getBondedDevices()) {
@@ -2029,7 +1561,7 @@ public class AdapterService extends Service {
         }
      }
 
-     private void adjustOtherSourcePriorities(A2dpService a2dpService,
+     private void adjustOtherSinkPriorities(A2dpService a2dpService,
                                                 BluetoothDevice connectedDevice) {
          for (BluetoothDevice device : getBondedDevices()) {
              if (a2dpService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
@@ -2039,16 +1571,6 @@ public class AdapterService extends Service {
          }
      }
 
-	 private void adjustOtherSinkPriorities(A2dpSinkService a2dpSinkService,
-                                                BluetoothDevice connectedDevice) {
-         for (BluetoothDevice device : getBondedDevices()) {
-             if (a2dpSinkService.getPriority(device) >= BluetoothProfile.PRIORITY_AUTO_CONNECT &&
-                 !device.equals(connectedDevice)) {
-                 a2dpSinkService.setPriority(device, BluetoothProfile.PRIORITY_ON);
-             }
-         }
-     }
-
      void setProfileAutoConnectionPriority (BluetoothDevice device, int profileId){
          if (profileId == BluetoothProfile.HEADSET) {
              HeadsetService  hsService = HeadsetService.getHeadsetService();
@@ -2063,18 +1585,10 @@ public class AdapterService extends Service {
              A2dpService a2dpService = A2dpService.getA2dpService();
              if ((a2dpService != null) &&
                 (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpService.getPriority(device))){
-                 adjustOtherSourcePriorities(a2dpService, device);
+                 adjustOtherSinkPriorities(a2dpService, device);
                  a2dpService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
              }
          }
-		 else if (profileId ==  BluetoothProfile.A2DP_SINK) {
-             A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
-             if ((a2dpSinkService != null) &&
-                (BluetoothProfile.PRIORITY_AUTO_CONNECT != a2dpSinkService.getPriority(device))){
-                 adjustOtherSinkPriorities(a2dpSinkService, device);
-                 a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_AUTO_CONNECT);
-             }
-         }
     }
 
      boolean cancelBondProcess(BluetoothDevice device) {
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterState.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterState.java
index eb34bc9..1ae367a 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterState.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/AdapterState.java
@@ -17,22 +17,15 @@
 package com.android.bluetooth.btservice;
 
 import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
 import android.content.Context;
 import android.content.Intent;
 import android.os.Message;
+import android.os.SystemProperties;
 import android.os.UserManager;
 import android.util.Log;
-import java.util.Arrays;
 
 import com.android.internal.util.State;
 import com.android.internal.util.StateMachine;
-import android.content.SharedPreferences;
-import android.content.res.Resources;
-import com.android.bluetooth.Utils;
-import android.preference.PreferenceManager;
-import com.broadcom.bt.settings.BluetoothAdvancedSettings;
-import com.broadcom.bt.settings.HeaderAdapter.HeaderViewHolder;
 
 /**
  * This state machine handles Bluetooth Adapter State.
@@ -73,19 +66,11 @@ final class AdapterState extends StateMachine {
     static final int BREDR_STOP_TIMEOUT = 107;
 
     static final int USER_TURN_OFF_DELAY_MS=500;
-    static final int USER_DEVICE_MODE_SWITCH = 300;
-    static final int DEVICE_MODE_DISCONNECT_PROFILES = 301;
-    static final int DEVICE_MODE_CHECK_DISCONNECTED_PROFILES = 302;
-    static final int DEVICE_MODE_SWITCH_SERVICES_TURN_OFF = 303;
-    static final int DEVICE_MODE_SWITCH_SERVICES_TURN_ON = 304;
-    static final int DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF = 305;
-    static final int DEVICE_MODE_SWITCH_SERVICES_TURNED_ON = 306;
-
-    static final int DEVICE_MODE_SWITCH_DISCONNECT_CHECK_MAX = 10;
 
     //TODO: tune me
     private static final int ENABLE_TIMEOUT_DELAY = 12000;
     private static final int DISABLE_TIMEOUT_DELAY = 8000;
+    private static final int UI_OVERHEAD_DELAY = 4000;
     private static final int BREDR_START_TIMEOUT_DELAY = 4000;
     //BLE_START_TIMEOUT can happen quickly as it just a start gattservice
     private static final int BLE_START_TIMEOUT_DELAY = 2000; //To start GattService
@@ -99,39 +84,7 @@ final class AdapterState extends StateMachine {
     private OnState mOnState = new OnState();
     private OffState mOffState = new OffState();
     private BleOnState mBleOnState = new BleOnState();
-
-	private int mDeviceMode = -1;
-    private int mPendingDeviceModeState = -1;
-    private int mPrevState = BluetoothAdapter.STATE_OFF;
-
-	public synchronized int getDeviceMode()
-    {
-        return mDeviceMode;
-    }
-
-    public synchronized void setDeviceMode(int devicemode)
-    {
-        mDeviceMode =devicemode;
-    }
-
-    public synchronized int getPendingDeviceMode()
-    {
-        return mPendingDeviceModeState;
-    }
-
-    public synchronized boolean isDeviceModeSwitchTurningOn() {
-        boolean isDeviceModeSwitchTurningOn=  mPendingCommandState.isDeviceModeSwitchTurningOn();
-        if (VDBG) Log.d(TAG,"isDeviceModeSwitchTurningOn()="+
-            isDeviceModeSwitchTurningOn);
-        return isDeviceModeSwitchTurningOn;
-    }
-
-    public synchronized boolean isDeviceModeSwitchTurningOff() {
-        boolean isDeviceModeSwitchTurningOff= mPendingCommandState.isDeviceModeSwitchTurningOff();
-        if (VDBG) Log.d(TAG,"isDeviceModeSwitchTurningOff()="
-            + isDeviceModeSwitchTurningOff);
-        return isDeviceModeSwitchTurningOff;
-    }
+    private int enable_timeout_delay;
 
     public boolean isTurningOn() {
         boolean isTurningOn=  mPendingCommandState.isTurningOn();
@@ -275,17 +228,14 @@ final class AdapterState extends StateMachine {
     private class OnState extends State {
         @Override
         public void enter() {
-            infoLog("Entering On State from state = " + mPrevState);
+            infoLog("Entering OnState");
 
             AdapterService adapterService = mAdapterService;
             if (adapterService == null) {
                 errorLog("Entered OnState after cleanup");
                 return;
             }
-            // Only autoconnect when BT is turned ON but not after device mode switch
-            if ((mPrevState == BluetoothAdapter.STATE_TURNING_ON))// ||
-				//(mPrevState == BluetoothAdapter.STATE_ON))
-            	adapterService.autoConnect();
+            adapterService.autoConnect();
         }
 
         @Override
@@ -314,17 +264,6 @@ final class AdapterState extends StateMachine {
                case USER_TURN_ON:
                    break;
 
-               case USER_DEVICE_MODE_SWITCH:
-                    // Start the device mode switching in Pending mode
-                   if (DBG) Log.d(TAG,"CURRENT_STATE=ON, MSG = USER_DEVICE_MODE_SWITCH");
-                   if (mPendingDeviceModeState != -1) {
-                       Log.d(TAG,"Error in setting USER_DEVICE_MODE_SWITCH");
-                       return false;
-                   }
-                   mPendingDeviceModeState = msg.arg1;
-                   transitionTo(mPendingCommandState);
-                   sendMessage(DEVICE_MODE_DISCONNECT_PROFILES);
-                   break;
                default:
                    return false;
             }
@@ -337,9 +276,6 @@ final class AdapterState extends StateMachine {
         private boolean mIsTurningOff;
         private boolean mIsBleTurningOn;
         private boolean mIsBleTurningOff;
-        private boolean mIsDeviceModeSwitchTurningOn = false;
-        private boolean mIsDeviceModeSwitchTurningOff = false;
-        private int mDisconnectCheckCount = 0;
 
         public void enter() {
             infoLog("Entering PendingCommandState");
@@ -377,21 +313,6 @@ final class AdapterState extends StateMachine {
             return mIsBleTurningOff;
         }
 
-        public void setDeviceModeSwitchTurningOn(boolean isTurningOn) {
-            mIsDeviceModeSwitchTurningOn = isTurningOn;
-        }
-
-        public boolean isDeviceModeSwitchTurningOn() {
-            return mIsDeviceModeSwitchTurningOn;
-        }
-
-        public void setDeviceModeSwitchTurningOff(boolean isTurningOff) {
-            mIsDeviceModeSwitchTurningOff = isTurningOff;
-        }
-
-        public boolean isDeviceModeSwitchTurningOff() {
-            return mIsDeviceModeSwitchTurningOff;
-        }
         @Override
         public boolean processMessage(Message msg) {
 
@@ -399,7 +320,6 @@ final class AdapterState extends StateMachine {
             boolean isTurningOff = isTurningOff();
             boolean isBleTurningOn = isBleTurningOn();
             boolean isBleTurningOff = isBleTurningOff();
-            mPrevState = mAdapterProperties.getState();
 
             AdapterService adapterService = mAdapterService;
             AdapterProperties adapterProperties = mAdapterProperties;
@@ -450,7 +370,13 @@ final class AdapterState extends StateMachine {
                         notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                         transitionTo(mOffState);
                     } else {
-                        sendMessageDelayed(ENABLE_TIMEOUT, ENABLE_TIMEOUT_DELAY);
+                        String timeout = SystemProperties.get("bluetooth.enable_timeout_ms");
+                        if (!timeout.isEmpty())
+                            enable_timeout_delay = Integer.parseInt(timeout) + UI_OVERHEAD_DELAY;
+                        else
+                            enable_timeout_delay = ENABLE_TIMEOUT_DELAY;
+                        Log.d(TAG, "enable_timeout_delay = " + enable_timeout_delay + " ms");
+                        sendMessageDelayed(ENABLE_TIMEOUT, enable_timeout_delay);
                     }
                     break;
 
@@ -557,107 +483,7 @@ final class AdapterState extends StateMachine {
                     notifyAdapterStateChange(BluetoothAdapter.STATE_OFF);
                     break;
 
-                case DEVICE_MODE_DISCONNECT_PROFILES:
-                    Log.d(TAG,"DEVICE_MODE_DISCONNECT_PROFILES");
-                    mDisconnectCheckCount = 0;
-                    mAdapterService.disconnectDeviceModeProfiles();
-                    sendMessageDelayed(
-                        DEVICE_MODE_CHECK_DISCONNECTED_PROFILES, 300);
-                    break;
-
-                case DEVICE_MODE_CHECK_DISCONNECTED_PROFILES:
-                    boolean isDisconnected =
-                            mAdapterService.isDeviceModeProfilesDisconnected();
-                    Log.d(TAG,"DEVICE_MODE_CHECK_DISCONNECTED_PROFILES isDisconnected="+
-                                isDisconnected+"mDisconnectCheckCount="+mDisconnectCheckCount);
-                    mDisconnectCheckCount++;
-                    if (!isDisconnected &&
-                            (mDisconnectCheckCount < DEVICE_MODE_SWITCH_DISCONNECT_CHECK_MAX)) {
-                        Log.d(TAG,"Device mode profile still not disconnected");
-                        sendMessageDelayed
-                            (DEVICE_MODE_CHECK_DISCONNECTED_PROFILES, 300);
-                    } else {
-                        mPendingCommandState.setDeviceModeSwitchTurningOff(true);
-                        sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_OFF);
-                    }
-                    break;
-
-                case DEVICE_MODE_SWITCH_SERVICES_TURN_OFF:
-                    // Initiate turn OFF the currnet Mode(Device/Phone) mode services
-                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURN_OFF "
-                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
-                    if (AdapterService.HEADSET_MODE == mPendingDeviceModeState) {
-                        // Turn off Default mode
-                        if(!mAdapterService.
-                            setProfileStateForDeviceModeSwitch(
-                                AdapterService.DEFAULT_MODE, false)) {
-                            Log.e(TAG, "No services to turn OFF HEADSET_MODE");
-                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF);
-                        }
-                    } else if (AdapterService.DEFAULT_MODE == mPendingDeviceModeState) {
-                        // Turn off Headset mode
-                        if(!mAdapterService.
-                            setProfileStateForDeviceModeSwitch(
-                                AdapterService.HEADSET_MODE, false)) {
-                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
-                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF);
-                        }
-                    }
-                    mIsDeviceModeSwitchTurningOff = true;
-                    break;
-
-                case DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF:
-                    // Adapter service notifies after the service turned off
-                    // Also continue now initiate turn ON the services for the new Mode(Device/Phone)
-                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURNED_OFF  "
-                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
-                    mIsDeviceModeSwitchTurningOff = false;
-                    //fallthrough.Now turn on the service required for Device mode switch
-                case DEVICE_MODE_SWITCH_SERVICES_TURN_ON:
-                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURN_ON "
-                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
-                    mDeviceMode = mPendingDeviceModeState;
-
-                    if (AdapterService.HEADSET_MODE == mPendingDeviceModeState) {
-                        // Turn ON Headset mode services
-                        if(!mAdapterService.
-                            setProfileStateForDeviceModeSwitch(
-                                AdapterService.HEADSET_MODE, true)) {
-                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
-                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_ON);
-                        }
-                    } else if (AdapterService.DEFAULT_MODE == mPendingDeviceModeState) {
-                        // Turn ON Default mode services
-                        if(!mAdapterService.
-                            setProfileStateForDeviceModeSwitch(
-                                AdapterService.DEFAULT_MODE, true)) {
-                            Log.e(TAG, "No services to turn OFF DEFAULT_MODE");
-                            sendMessage(DEVICE_MODE_SWITCH_SERVICES_TURN_ON);
-                        }
-                    }
-                    mIsDeviceModeSwitchTurningOn = true;
-                    break;
-
-                case DEVICE_MODE_SWITCH_SERVICES_TURNED_ON:
-                    // Adapter service notifies after the service turned ON
-                    // Now restore from  pending state to Previous ON state
-                    Log.d(TAG,"DEVICE_MODE_SWITCH_SERVICES_TURNED_ON  "
-                        +"mPendingDeviceModeState="+mPendingDeviceModeState);
-                    mPendingDeviceModeState = -1;
-                    mIsDeviceModeSwitchTurningOn = false;
-                    mAdapterService.broadcastDeviceModeSwitchStatus();
-                    int adapterState = mAdapterService.getState();
-                    if (adapterState == BluetoothAdapter.STATE_ON)
-                        transitionTo(mOnState);
-                    else if (adapterState == BluetoothAdapter.STATE_BLE_ON)
-                        transitionTo(mBleOnState);
-                    else
-                        transitionTo(mOffState);
-
-                    break;
                 default:
-                    if (DBG) Log.d(TAG,"ERROR:UNEXPECTED MSG:CURRENT_STATE=PENDING,MSG = " +
-                                   msg.what);
                     return false;
             }
             return true;
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/BondStateMachine.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/BondStateMachine.java
index 2fdd042..7bed94a 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/BondStateMachine.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/BondStateMachine.java
@@ -21,7 +21,6 @@ import android.bluetooth.BluetoothClass;
 import android.bluetooth.BluetoothProfile;
 import android.bluetooth.BluetoothDevice;
 import com.android.bluetooth.a2dp.A2dpService;
-import com.android.bluetooth.a2dp.A2dpSinkService;
 import com.android.bluetooth.hid.HidService;
 import com.android.bluetooth.hfp.HeadsetService;
 import android.content.Context;
@@ -435,7 +434,6 @@ final class BondStateMachine extends StateMachine {
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
-        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
 
         if ((hidService != null) &&
             (hidService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
@@ -447,11 +445,6 @@ final class BondStateMachine extends StateMachine {
             a2dpService.setPriority(device,BluetoothProfile.PRIORITY_ON);
         }
 
-        if ((a2dpSinkService != null) &&
-            (a2dpSinkService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
-            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_ON);
-        }
-
         if ((headsetService != null) &&
             (headsetService.getPriority(device) == BluetoothProfile.PRIORITY_UNDEFINED)){
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_ON);
@@ -462,7 +455,6 @@ final class BondStateMachine extends StateMachine {
         HidService hidService = HidService.getHidService();
         A2dpService a2dpService = A2dpService.getA2dpService();
         HeadsetService headsetService = HeadsetService.getHeadsetService();
-        A2dpSinkService a2dpSinkService = A2dpSinkService.getA2dpSinkService();
 
         if (hidService != null)
             hidService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
@@ -470,8 +462,6 @@ final class BondStateMachine extends StateMachine {
             a2dpService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
         if(headsetService != null)
             headsetService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
-        if(a2dpSinkService != null)
-            a2dpSinkService.setPriority(device,BluetoothProfile.PRIORITY_UNDEFINED);
     }
 
     private void infoLog(String msg) {
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/ProfileService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/ProfileService.java
index 02e0555..7a6908f 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/ProfileService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/btservice/ProfileService.java
@@ -31,7 +31,7 @@ import android.os.IBinder;
 import android.util.Log;
 
 public abstract class ProfileService extends Service {
-    private static final boolean DBG = true;
+    private static final boolean DBG = false;
     private static final String TAG = "BluetoothProfileService";
 
     //For Debugging only
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/hfp/HeadsetService.java b/packages/apps/Bluetooth/src/com/android/bluetooth/hfp/HeadsetService.java
index 28f9d3f..f6153cb 100755
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/hfp/HeadsetService.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/hfp/HeadsetService.java
@@ -36,7 +36,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Iterator;
 import java.util.Map;
-import android.os.SystemClock;
 
 /**
  * Provides Bluetooth Headset and Handsfree profile, as a service in
@@ -79,9 +78,7 @@ public class HeadsetService extends ProfileService {
         } catch (Exception e) {
             Log.w(TAG,"Unable to unregister headset receiver",e);
         }
-        if(mStateMachine != null) {
-            mStateMachine.doQuit();
-        }
+        mStateMachine.doQuit();
         return true;
     }
 
@@ -349,7 +346,7 @@ public class HeadsetService extends ProfileService {
         return true;
     }
 
-    public boolean disconnect(BluetoothDevice device) {
+    boolean disconnect(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_ADMIN_PERM,
                                        "Need BLUETOOTH ADMIN permission");
         int connectionState = mStateMachine.getConnectionState(device);
@@ -364,32 +361,14 @@ public class HeadsetService extends ProfileService {
 
     public List<BluetoothDevice> getConnectedDevices() {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-		
-		int counter = 1000;  //counter x 15ms = 15s
-		while (mStateMachine == null) {
-			Log.d(TAG, "getConnectedDevices counter=%d"+counter);
-			if (counter <= 0) {
-				break;
-			}
-			SystemClock.sleep(15);
-			counter--;
-		}
-		
         return mStateMachine.getConnectedDevices();
     }
 
-    public List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
+    private List<BluetoothDevice> getDevicesMatchingConnectionStates(int[] states) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getDevicesMatchingConnectionStates(states);
     }
 
-    public List<BluetoothDevice> getConnectedDevicesAll() {
-        enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
-        return getDevicesMatchingConnectionStates(
-              new int[] {BluetoothProfile.STATE_CONNECTED,
-                         BluetoothProfile.STATE_CONNECTING});
-    }
-
     int getConnectionState(BluetoothDevice device) {
         enforceCallingOrSelfPermission(BLUETOOTH_PERM, "Need BLUETOOTH permission");
         return mStateMachine.getConnectionState(device);
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientHalConstants.java b/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientHalConstants.java
index b3488e4..ba9655d 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientHalConstants.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientHalConstants.java
@@ -172,5 +172,5 @@ final public class HeadsetClientHalConstants {
     final static int HANDSFREECLIENT_AT_CMD_NREC = 15;
 
     // Flag to check for local NREC support
-    final static boolean HANDSFREECLIENT_NREC_SUPPORTED = false;
+    final static boolean HANDSFREECLIENT_NREC_SUPPORTED = true;
 }
diff --git a/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java b/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
index 82a014f..2906330 100644
--- a/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
+++ b/packages/apps/Bluetooth/src/com/android/bluetooth/hfpclient/HeadsetClientStateMachine.java
@@ -2073,8 +2073,6 @@ final class HeadsetClientStateMachine extends StateMachine {
                         Log.d(TAG,"stopping ring and request focus for call");
                         mRingtone.stop();
                     }
-
-                    mAudioManager.setParameters("hfp_enable=true");
                     int newAudioMode = AudioManager.MODE_IN_CALL;
                     int currMode = mAudioManager.getMode();
                     if (currMode != newAudioMode) {
@@ -2095,7 +2093,7 @@ final class HeadsetClientStateMachine extends StateMachine {
                         Log.d(TAG,"Setting sampling rate as 8000");
                         mAudioManager.setParameters("hfp_set_sampling_rate=8000");
                     }
-                    //mAudioManager.setParameters("hfp_enable=true");
+                    mAudioManager.setParameters("hfp_enable=true");
                     broadcastAudioState(device, BluetoothHeadsetClient.STATE_AUDIO_CONNECTED,
                             BluetoothHeadsetClient.STATE_AUDIO_CONNECTING);
                     transitionTo(mAudioOn);
diff --git a/packages/apps/Bluetooth/src/com/broadcom/bt/service/IProfileStateChangeListener.java b/packages/apps/Bluetooth/src/com/broadcom/bt/service/IProfileStateChangeListener.java
deleted file mode 100644
index 0b02dfa..0000000
--- a/packages/apps/Bluetooth/src/com/broadcom/bt/service/IProfileStateChangeListener.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2012 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.service;
-
-public interface IProfileStateChangeListener {
-    public void onProfileStateChanged(String profileName, int newState, int oldState);
-    public void onDeviceModeSwitchComplete();
-}
diff --git a/packages/apps/Bluetooth/src/com/broadcom/bt/service/ProfileConfig.java b/packages/apps/Bluetooth/src/com/broadcom/bt/service/ProfileConfig.java
deleted file mode 100644
index 5c2355e..0000000
--- a/packages/apps/Bluetooth/src/com/broadcom/bt/service/ProfileConfig.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2012 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.service;
-
-import java.util.ArrayList;
-
-import android.content.ContentResolver;
-import android.content.Context;
-import android.content.res.Resources;
-import android.provider.Settings;
-import android.util.Log;
-
-import com.android.bluetooth.R;
-import com.android.bluetooth.a2dp.A2dpService;
-import com.android.bluetooth.a2dp.A2dpSinkService;
-import com.android.bluetooth.btservice.Config;
-import com.android.bluetooth.hdp.HealthService;
-import com.android.bluetooth.hfp.HeadsetService;
-import com.android.bluetooth.hid.HidService;
-import com.android.bluetooth.pan.PanService;
-import com.android.bluetooth.avrcp.AvrcpControllerService;
-import com.android.bluetooth.sap.SapService;
-
-import com.android.bluetooth.gatt.GattService;
-
-import com.android.bluetooth.map.BluetoothMapService;
-import com.android.bluetooth.hfpclient.HeadsetClientService;
-
-import com.android.bluetooth.btservice.AdapterService;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-
-
-
-
-/**
- * Overrides the Bluedroid standard profile config and adds Broadcom specific
- * profiles
- *
- * @author fredc
- *
- */
-public class ProfileConfig extends Config {
-    private static final String TAG = "BtSettings.ProfileConfig";
-    private static Context mContext;
-    /**
-     * List of profile services.
-     */
-    private static final int INDEX_CLASS_NAME=0;
-    private static final int INDEX_NAME=1;
-    private static final int INDEX_DESCRIPTION=2;
-    private static final int INDEX_SUPPORTED=3;
-    private static final int INDEX_DEFAULT_START=4;
-    private static final int INDEX_CONFIGURABLE=5;
-    private static final int INDEX_CFG_DEVICE_MODE = 6;
-    private static final int INDEX_DETAILED_FRAGMENT= 7;
-
-    // Profile will run in both device and phone mode and is Independent of device mode switching
-    // Typically for the profile which is not concerned about "device mode switching"
-    // will use CFG_MODE_DUAL
-    public static final int CFG_MODE_DUAL = 0;
-
-    // The profile will run only on Device and will be disabled in TV mode
-    public static final int CFG_MODE_DEVICE = 1;
-    // The profile will run only on TV and will be disabled in device mode
-    public static final int CFG_MODE_TV = 2;
-    // The same service supports both DEVICE and PHONE so a stop and restart
-    // of the same service is required when mode switch happens
-    public static final int CFG_MODE_DEVICE_OR_PHONE = 3;
-
-
-    // Do not include OPP and PBAP, because their services
-    // are not managed by AdapterService
-    private static final Object[][] PROFILE_SERVICES= {
-        //Headset/HFP configuration
-        {   HeadsetService.class,
-            R.string.profile_hs_hfp,
-            R.string.profile_description_hs_hfp,
-            R.bool.profile_supported_hs_hfp,
-            R.bool.profile_default_start_hs_hfp,
-            R.bool.profile_configurable_hs_hfp,
-            R.integer.profile_cfg_run_in_device_mode_hs_hfp,
-            null }
-        ,
-        //A2DP configuration
-        {   A2dpService.class,
-            R.string.profile_a2dp,
-            R.string.profile_description_a2dp,
-            R.bool.profile_supported_a2dp,
-            R.bool.profile_default_start_a2dp,
-            R.bool.profile_configurable_a2dp,
-            R.integer.profile_cfg_run_in_device_mode_a2dp,
-            null }
-        ,
-
-        //HID Host configuration
-        {   HidService.class,
-            R.string.profile_hid,
-            R.string.profile_description_hid,
-            R.bool.profile_supported_hid,
-            R.bool.profile_default_start_hid,
-            R.bool.profile_configurable_hid,
-            R.integer.profile_cfg_run_in_device_mode_hid,
-            null }
-        ,
-        //Heath Profile configuration
-        {   HealthService.class,
-            R.string.profile_hdp,
-            R.string.profile_description_hdp,
-            R.bool.profile_supported_hdp,
-            R.bool.profile_default_start_hdp,
-            R.bool.profile_configurable_hdp,
-            R.integer.profile_cfg_run_in_device_mode_hdp,
-            null }
-        ,
-        //PAN configuration
-        {   PanService.class,
-            R.string.profile_pan,
-            R.string.profile_description_pan,
-            R.bool.profile_supported_pan,
-            R.bool.profile_default_start_pan,
-            R.bool.profile_configurable_pan,
-            R.integer.profile_cfg_run_in_device_mode_pan,
-            null }
-        ,
-        //Gatt configuration
-        {   GattService.class,
-            R.string.profile_gatt,
-            R.string.profile_description_gatt,
-            R.bool.profile_supported_gatt,
-            R.bool.profile_default_start_gatt,
-            R.bool.profile_configurable_gatt,
-            R.integer.profile_cfg_run_in_device_mode_gatt,
-            null }
-        ,
-        //MAP configuration (AOSP MAP Server)
-        {   BluetoothMapService.class,
-            R.string.profile_mse,
-            R.string.profile_description_mse,
-            R.bool.profile_supported_map,
-            R.bool.profile_default_start_mse,
-            R.bool.profile_configurable_mse,
-            R.integer.profile_cfg_run_in_device_mode_mse,
-            null
-            }
-        ,
-        //Sap configuration
-        {   SapService.class,
-            R.string.profile_sap,
-            R.string.profile_description_sap,
-            R.bool.profile_supported_sap,
-            R.bool.profile_default_start_sap,
-            R.bool.profile_configurable_sap,
-            R.integer.profile_cfg_run_in_device_mode_sap,
-            null }
-        ,
-        //AVRCP Controller profile configuration
-        {   AvrcpControllerService.class,
-            R.string.profile_avrcp_ct,
-            R.string.profile_description_avrcp_ct,
-            R.bool.profile_supported_avrcp_controller,
-            R.bool.profile_default_start_avrcp_ct,
-            R.bool.profile_configurable_avrcp_ct,
-            R.integer.profile_cfg_run_in_device_mode_avrcp_ct,
-            null }
-        ,
-        //HF client profile configuration (AOSP HF client implementation)
-        {   HeadsetClientService.class,
-            R.string.profile_hfclient,
-            R.string.profile_description_hfdevice,
-            R.bool.profile_supported_hfpclient,
-            R.bool.profile_default_start_hfclient,
-            R.bool.profile_configurable_hfclient,
-            R.integer.profile_cfg_run_in_device_mode_hfclient,
-            null }
-        ,
-        //A2DP SINK configuration
-        {   A2dpSinkService.class,
-            R.string.profile_a2dp_sink,
-            R.string.profile_description_a2dp_sink,
-            R.bool.profile_supported_a2dp_sink,
-            R.bool.profile_default_start_a2dp_sink,
-            R.bool.profile_configurable_a2dp_sink,
-            R.integer.profile_cfg_run_in_device_mode_a2dp_sink,
-            null }
-    };
-
-    public static class ProfileCfg {
-        public String mName;
-        public String mDisplayName;
-        public String mDescription;
-        public boolean mDefaultStarted;
-        public boolean mUserConfigurable;
-        public int mDeviceModeCfg;
-        public String mSettingsActivityPkgClassName;
-    }
-
-    @SuppressWarnings("rawtypes")
-    private static Class[] SUPPORTED_PROFILES = new Class[0];
-    private static Class[] QUIET_MODE_PROFILES = new Class[0];
-    private static ProfileCfg[] SUPPORTED_PROFILES_CFG = new ProfileCfg[0];
-    private static final String SETTINGS_PREFIX = "bt_svcst_";
-
-    private static  boolean mDeviceModeCfgSupported = true;
-
-    private static void initSettings() {
-        // Initialize Bluetooth profile settins
-        if (mContext != null) {
-            ContentResolver cr = mContext.getContentResolver();
-            boolean settingsExist =  Settings.Global.getInt(cr, SETTINGS_PREFIX + "init", 0) != 0;
-            if (!settingsExist) {
-                Log.i(TAG, "*********Initializing Bluetooth Profile Settings*******");
-                for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++) {
-                    ProfileCfg cfg = SUPPORTED_PROFILES_CFG[i];
-                    Settings.Global.putInt(cr, SETTINGS_PREFIX + cfg.mName, cfg.mDefaultStarted ? 1
-                            : 0);
-                }
-                Settings.Global.putInt(cr, SETTINGS_PREFIX + "init", 1);
-            }
-
-        }
-    }
-
-    private static void checkAndAdjustDeviceModeConfiguration() {
-
-        SharedPreferences settings = PreferenceManager.
-            getDefaultSharedPreferences(mContext);
-        int deviceMode = settings.getInt("DEVICEMODE",-1);
-        Log.d(TAG,"deviceMode from shared preference   " + deviceMode );
-        if( deviceMode == -1 )
-        {
-            Resources r = mContext.getResources();
-            boolean isDevicemode = r
-                    .getBoolean(com.android.bluetooth.R.bool.tv_mode);
-            if( isDevicemode )
-                deviceMode = AdapterService.DEFAULT_MODE;
-            else
-                deviceMode = AdapterService.HEADSET_MODE;
-        }
-        Log.d(TAG,"checkAndAdjustDeviceModeConfiguration deviceMode" + deviceMode );
-
-        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++) {
-            boolean isProfileEnabled = isProfileConfiguredEnabled(SUPPORTED_PROFILES_CFG[i].mName);
-            if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE) {
-                //Enable Device mode profile if not enabled
-                //and disable Phone mode services if enabled
-                if ((AdapterService.HEADSET_MODE == deviceMode) &&
-                    !isProfileEnabled)
-                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
-                else if ((AdapterService.DEFAULT_MODE == deviceMode) &&
-                    isProfileEnabled &&
-                    // If service is configurable in UI leave the recovery state control to user
-                    (SUPPORTED_PROFILES_CFG[i].mUserConfigurable == false))
-                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,false);
-            } else if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_TV) {
-                //Enable Phone mode profile if not enabled
-                //and disable Device mode services if enabled
-                if ((AdapterService.DEFAULT_MODE == deviceMode) &&
-                    !isProfileEnabled)
-                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
-                else if ((AdapterService.HEADSET_MODE == deviceMode) &&
-                    isProfileEnabled)
-                    saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,false);
-            } else if (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE
-                     && !isProfileEnabled) {
-                     // For Device and Phone mode service enable if not enabled
-                 saveProfileSetting(SUPPORTED_PROFILES_CFG[i].mName,true);
-            }
-        }
-
-    }
-
-    @SuppressWarnings("rawtypes")
-    public static void init(Context ctx) {
-        if (ctx == null) {
-            return;
-        }
-        mContext = ctx;
-        Resources resources = ctx.getResources();
-        if (resources == null) {
-            return;
-        }
-        ArrayList<Class> profiles = new ArrayList<Class>(PROFILE_SERVICES.length);
-        ArrayList<ProfileCfg> cfgs = new ArrayList<ProfileCfg>(PROFILE_SERVICES.length);
-        for (int i = 0; i < PROFILE_SERVICES.length; i++) {
-            boolean supported = resources.getBoolean((Integer)PROFILE_SERVICES[i][INDEX_SUPPORTED]);
-            if (supported) {
-                Class profile = (Class)PROFILE_SERVICES[i][INDEX_CLASS_NAME];
-                Log.d(TAG, "Adding " +profile.getSimpleName());
-                profiles.add(profile);
-
-                ProfileCfg cfg = new ProfileCfg();
-                cfg.mName = profile.getName();
-                // Add display name
-                String displayName = null;
-                try {
-                    displayName = resources.getString((Integer)PROFILE_SERVICES[i][INDEX_NAME]);
-                } catch (Throwable t) {
-                    Log.w(TAG, "Profile display name not found", t);
-                }
-                cfg.mDisplayName = (displayName == null ? profile.getName()
-                        : displayName);
-
-                // Add description
-                String description = null;
-                try {
-                    description = resources.getString
-                            ((Integer)PROFILE_SERVICES[i][INDEX_DESCRIPTION]);
-                } catch (Throwable t) {
-                    Log.w(TAG, "Profile display name not found", t);
-                }
-                cfg.mDescription = (description == null ? profile.getName()
-                        : description);
-
-                // Add configuration flags
-                cfg.mDefaultStarted = resources.getBoolean
-                        ((Integer)PROFILE_SERVICES[i][INDEX_DEFAULT_START]);
-                cfg.mUserConfigurable = resources
-                        .getBoolean((Integer)PROFILE_SERVICES[i][INDEX_CONFIGURABLE]);
-                cfg.mDeviceModeCfg = resources
-                        .getInteger((Integer)PROFILE_SERVICES[i][INDEX_CFG_DEVICE_MODE]);
-                // Add activity
-                cfg.mSettingsActivityPkgClassName =
-                        ((String)PROFILE_SERVICES[i][INDEX_DETAILED_FRAGMENT]);
-                cfgs.add(cfg);
-            }
-        }
-        int totalProfiles = profiles.size();
-        SUPPORTED_PROFILES = new Class[totalProfiles];
-        SUPPORTED_PROFILES_CFG = new ProfileCfg[totalProfiles];
-        for (int i = 0; i < totalProfiles; i++) {
-            SUPPORTED_PROFILES[i] = profiles.get(i);
-            SUPPORTED_PROFILES_CFG[i] = cfgs.get(i);
-        }
-        mDeviceModeCfgSupported = resources.getBoolean((Integer)R.bool.supports_device_mode_cfg);
-
-        initSettings();
-        checkAndAdjustDeviceModeConfiguration();
-    }
-
-    private static int findProfileIndex(String className) {
-        for (int i = 0; i < SUPPORTED_PROFILES.length; i++) {
-            if (className.equals(SUPPORTED_PROFILES[i].getName())) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    @SuppressWarnings("rawtypes")
-    public static Class[] getSupportedProfiles() {
-        return SUPPORTED_PROFILES;
-    }
-
-    public static ProfileCfg[] getSupportedProfileCfgs() {
-        return SUPPORTED_PROFILES_CFG;
-    }
-
-    public boolean isProfileSupported(String profileName) {
-        return findProfileIndex(profileName) >= 0;
-    }
-
-
-    public static boolean isDeviceModeProfile(String profileName) {
-        if ( mDeviceModeCfgSupported== false) {
-            // Device mode configuration is not supported. Return false by default for all profiles.
-            return false;
-        }
-        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++)
-            if (SUPPORTED_PROFILES_CFG[i].mName.equals(profileName) &&
-                (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE ||
-                SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE))
-                return true;
-        return false;
-    }
-
-    public static boolean isPhoneModeProfile(String profileName) {
-        if ( mDeviceModeCfgSupported== false) {
-            // Device mode configuration is not supported. Return false by default for all profiles.
-            return false;
-        }
-        for (int i = 0; i < SUPPORTED_PROFILES_CFG.length; i++)
-            if (SUPPORTED_PROFILES_CFG[i].mName.equals(profileName) &&
-                (SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_TV ||
-                SUPPORTED_PROFILES_CFG[i].mDeviceModeCfg == CFG_MODE_DEVICE_OR_PHONE))
-                return true;
-        return false;
-    }
-
-
-    /**
-     * Save the profile state (on or off)
-     *
-     * @param on
-     * @return
-     */
-    public static void saveProfileSetting(String profileName, boolean enabled) {
-        Log.d(TAG,"saveProfileSetting profileName= "+profileName+"enabled"+enabled);
-        if (mContext != null) {
-            ContentResolver cr = mContext.getContentResolver();
-            int profileIndex = findProfileIndex(profileName);
-            if (profileIndex < 0) {
-                Log.w(TAG, "Profile not supported: " + profileName);
-                return;
-            }
-
-            Settings.Global.putInt(cr, SETTINGS_PREFIX + profileName, enabled ? 1 : 0);
-        }
-    }
-
-    public static boolean isProfileConfiguredEnabled(String profileName) {
-        int profileIndex = findProfileIndex(profileName);
-        if (profileIndex < 0) {
-            return false;
-        }
-
-        if (mContext != null) {
-            ContentResolver cr = mContext.getContentResolver();
-            try {
-                Log.d(TAG, "getProfileSaveSetting: " + profileName);
-                return Settings.Global.getInt(cr, SETTINGS_PREFIX + profileName) == 1;
-            } catch (Throwable t) {
-                Log.d(TAG, "Unable to read settings", t);
-            }
-        }
-        // If the profile entry not present,
-        // return true assuming by default a profile is always enabled.
-        return true;
-    }
-
-}
diff --git a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java b/packages/apps/Bluetooth/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java
deleted file mode 100644
index e4ddca8..0000000
--- a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/BluetoothAdvancedSettings.java
+++ /dev/null
@@ -1,533 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2012-2013 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.settings;
-
-import java.util.List;
-
-import com.android.bluetooth.R;
-import com.android.bluetooth.btservice.AdapterService;
-
-import com.broadcom.bt.service.IProfileStateChangeListener;
-import com.broadcom.bt.service.ProfileConfig;
-import com.broadcom.bt.service.ProfileConfig.ProfileCfg;
-
-import com.broadcom.bt.settings.HeaderAdapter.HeaderViewHolder;
-import com.broadcom.bt.service.settings.ModeAdvancedSettings;
-
-import android.bluetooth.BluetoothAdapter;
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.preference.PreferenceActivity;
-import android.preference.PreferenceActivity.Header;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.Button;
-import android.widget.CompoundButton;
-import android.widget.ImageView;
-import android.widget.ListAdapter;
-import android.widget.Switch;
-import android.widget.TextView;
-import android.content.res.Resources;
-import android.app.Activity;
-
-import android.content.ContentResolver;
-import android.provider.Settings;
-import android.content.SharedPreferences;
-import android.preference.PreferenceManager;
-
-import com.android.bluetooth.hfp.HeadsetService;
-
-public class BluetoothAdvancedSettings extends PreferenceActivity implements
-        HeaderAdapter.OnCheckedChangeListener, IProfileStateChangeListener {
-    private static final String TAG = "BtSettings.BluetoothAdvancedSettings";
-    public static final String EXTRA_PROFILE_NAME = "profileName";
-
-    public static final String EXTRA_DEVICE_MODE = "deviceMode";
-
-    private static final String SETTINGS_PREFIX = "bt_svcst_";
-    private static Context mContext;
-    private static final Object[] MODE= {
-                            R.string.active_mode
-                        };
-
-    private static boolean isDeviceModeSwitchInProgress = false;
-
-    private static class AdvancedSettingsHeaderAdapter extends HeaderAdapter {
-        public boolean getSwitchState(Header header) {
-       String deviceModeName = header.extras
-                   .getString(BluetoothAdvancedSettings.EXTRA_DEVICE_MODE);
-
-            if (deviceModeName != null)
-            {
-                Log.d(TAG, "Getting device mode switch state for " + deviceModeName);
-                boolean isEnabled = isDeviceModeEnabled(deviceModeName);
-                Log.d(TAG, "device mode enabled? " + isEnabled);
-                return isEnabled;
-            }
-
-            String profileName = header.extras
-                    .getString(BluetoothAdvancedSettings.EXTRA_PROFILE_NAME);
-            Log.d(TAG, "Getting switch state for " + profileName);
-            boolean isEnabled = isProfileEnabledAndStarted(profileName);
-            Log.d(TAG, "Profile enabled? " + isEnabled);
-            return isEnabled;
-        }
-
-        public AdvancedSettingsHeaderAdapter(Context context, List<Header> objects) {
-            super(context, objects);
-        }
-
-        protected int getHeaderType(Header header) {
-            return HEADER_TYPE_SWITCH;
-        }
-
-        protected int getHeaderLayoutResId(int headerType) {
-            switch (headerType) {
-            case HEADER_TYPE_SWITCH:
-                return R.layout.preference_header_switch_item;
-            }
-            return -1;
-        }
-
-    }
-
-    protected boolean isValidFragment(String fragmentName) {
-        // TODO: Check validation of fragment after adding fragment.
-        return true;
-    }
-
-    private static boolean isProfileServiceStarted(String profileName) {
-        AdapterService svc = AdapterService.getAdapterService();
-        if (svc == null) {
-            return false;
-        }
-        return svc.isProfileStarted(profileName);
-    }
-
-    private static boolean isProfileEnabledAndStarted(String profileName) {
-        return ProfileConfig.isProfileConfiguredEnabled(profileName)
-                && isProfileServiceStarted(profileName);
-    }
-
-
-    private boolean setProfileState(String profileName, boolean setEnabled) {
-        ProfileConfig.saveProfileSetting(profileName, setEnabled);
-        AdapterService svc = AdapterService.getAdapterService();
-        boolean result = false;
-        if (svc == null) {
-            return false;
-        }
-        svc.setProfileStateChangeListener(this);
-
-        ProfileConfig.saveProfileSetting(profileName, setEnabled);
-
-        result = svc.setProfileState(profileName, setEnabled);
-
-        if (result == true)
-            svc.sendUUIDChange(AdapterService.MESSAGE_DELAY_FOR_SEND_UUID_CHANGED);
-
-        return result;
-    }
-
-
-    AdvancedSettingsHeaderAdapter mAdapter;
-    AdapterService mService;
-
-	
-	public void onHeaderClick (Header header, int position) {
-		Log.d(TAG, "onHeaderClick header="+header+" position="+position);
-	}
-
-    protected void onCreate(Bundle savedInstanceState) {
-        Log.d(TAG, "onCreate"+mAdapter);
-        super.onCreate(savedInstanceState);
-        mService = AdapterService.getAdapterService();
-
-        if (mService != null) {
-            mService.setProfileStateChangeListener(this);
-        }
-    }
-
-    protected void onDestroy() {
-        Log.d(TAG, "onDestroy"+mAdapter);
-        if (mService != null) {
-            mService.unsetProfileStateChangeListener();
-            mService = null;
-        }
-        super.onDestroy();
-    }
-
-    public void onResume() {
-     Log.d(TAG, "onResume");
-
-     super.onResume();
-
-     if (mService != null) {
-         mService.setProfileStateChangeListener(this);
-     }
-
-
-     if (mAdapter == null) {
-         Log.w(TAG, "onResume(): mAdapter not found");
-         return;
-     }
-
-     int count = mAdapter.getCount();
-     for (int i = 0; i < count; i++) {
-         Header header = (Header) mAdapter.getItem(i);
-         String name = null;
-         if (header != null && header.extras != null
-                 && (name = header.extras.getString(EXTRA_DEVICE_MODE)) != null) {
-             HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
-             if (viewHolder != null && viewHolder.switch_ != null) {
-                 final CompoundButton button = viewHolder.switch_;
-                 runOnUiThread(new Runnable() {
-                     @Override
-                     public void run() {
-                     BluetoothAdapter btAdapter = BluetoothAdapter.getDefaultAdapter();
-                     // Do it only when there is no devie mode switch in progress
-                     // and Device mode Button is disabled due to device mode switch
-                      //if ((!button.isEnabled()) && (isDeviceModeSwitchInProgress == false) )
-                      //   button.setEnabled(true);
-                     }
-                 });
-             }
-         }
-     }
-
-    }
-
-
-    public void onPause() {
-     Log.d(TAG, "onPause");
-        super.onPause();
-    }
-
-    @Override
-    public void onBuildHeaders(List<Header> headers) {
-        // Get a list of Bluetooth Profiles and add them
-        ProfileCfg[] supportedProfileCfgs = ProfileConfig.getSupportedProfileCfgs();
-        for (int i = 0; i < supportedProfileCfgs.length; i++) {
-            ProfileCfg p = supportedProfileCfgs[i];
-            try {
-                if (p.mUserConfigurable && ((p.mDeviceModeCfg != ProfileConfig.CFG_MODE_DEVICE) &&
-                (p.mDeviceModeCfg != ProfileConfig.CFG_MODE_TV))) {
-                    Header h = new Header();
-                    h.title = p.mDisplayName;
-                    h.summary = p.mDescription;
-                    h.extras = new Bundle();
-                    h.extras.putString(EXTRA_PROFILE_NAME, p.mName);
-                    h.fragment= ModeAdvancedSettings.class.getName();
-                    headers.add(h);
-                }
-            } catch (Throwable t) {
-                Log.w(TAG, "Error loading profile state: " + p.mName, t);
-            }
-        }
-
-        // FIXME -- merge with existing framework
-        mContext = this.getApplicationContext();
-            Resources resources = mContext.getResources();
-        String displayName = null;
-        String deviceModesummary = null;
-        int a2dpProfileDeviceMode = resources
-                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_a2dp);
-        int a2dpSinkProfileDeviceMode = resources
-                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_a2dp_sink);
-
-        int hfDeviceProfileDeviceMode = resources
-                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_hfdevice);
-        int headsetProfileDeviceMode = resources
-                    .getInteger((Integer)R.integer.profile_cfg_run_in_device_mode_hs_hfp);
-
-
-        if ((ProfileConfig.CFG_MODE_TV == a2dpProfileDeviceMode) &&
-            (ProfileConfig.CFG_MODE_DEVICE == a2dpSinkProfileDeviceMode) &&
-                (ProfileConfig.CFG_MODE_DEVICE == hfDeviceProfileDeviceMode) &&
-                (ProfileConfig.CFG_MODE_TV == headsetProfileDeviceMode) &&
-                (true == resources.getBoolean(R.bool.profile_supported_a2dp)) &&
-                (true == resources.getBoolean(R.bool.profile_supported_hfdevice)))
-            deviceModesummary = "AV-Src & HFP-AG when ON/ AVK & HFP-HF when OFF";
-        else if ((ProfileConfig.CFG_MODE_TV == a2dpProfileDeviceMode) &&
-                (ProfileConfig.CFG_MODE_DEVICE == a2dpSinkProfileDeviceMode) &&
-                (true == resources.getBoolean(R.bool.profile_supported_a2dp)))
-            deviceModesummary = "AV-Src when ON/ AVK when OFF";
-        else if ((ProfileConfig.CFG_MODE_DEVICE == hfDeviceProfileDeviceMode) &&
-                (ProfileConfig.CFG_MODE_TV == headsetProfileDeviceMode) &&
-                (true == resources.getBoolean(R.bool.profile_supported_hfdevice)))
-            deviceModesummary = "HFP-AG when ON/ HFP-HF when OFF";
-
-        if(null == deviceModesummary)// Do not shown configurable option in Advanced Settings
-            return;
-
-
-        try {
-            //resources.getString((Integer)MODE[0]);
-            displayName = resources.getString(R.string.TV_mode);
-            if (displayName == null)
-                return;
-            Header h = new Header();
-            h.title = displayName;
-            h.summary = deviceModesummary;
-            h.extras = new Bundle();
-            h.extras.putString(EXTRA_DEVICE_MODE, displayName);
-            h.fragment=ModeAdvancedSettings.class.getName();
-            headers.add(h);
-        } catch (Throwable t) {
-            Log.w(TAG, "Error loading :" + displayName );
-        }
-    }
-
-    @Override
-    public void setListAdapter(ListAdapter adapter) {
-        if (adapter == null) {
-            super.setListAdapter(null);
-        } else {
-            mAdapter = new AdvancedSettingsHeaderAdapter(this, getHeaders());
-            mAdapter.setCheckedChangeListener(this);
-            super.setListAdapter(mAdapter);
-        }
-    }
-
- public boolean setDeviceMode( String deviceModeName,boolean isChecked, int deviceMode) {
-        saveDeviceModeSetting(deviceModeName, isChecked);
-        AdapterService svc = AdapterService.getAdapterService();
-        if (svc == null) {
-            return false;
-        }
-        mContext = this.getApplicationContext();
-        SharedPreferences.Editor editor = PreferenceManager.
-            getDefaultSharedPreferences(mContext).edit();
-
-        svc.setProfileStateChangeListener(this);
-
-        Log.d(TAG,"BluetoothAdvancedSettings  mDeviceMode   " + deviceMode );
-        editor.putInt("DEVICEMODE",deviceMode);
-        editor.apply();
-        isDeviceModeSwitchInProgress = true;
-
-        return svc.setDeviceMode(deviceMode);
-    }
-
-
-     @Override
-    public void onCheckedChanged(int position, boolean isChecked) {
-        if (mAdapter == null) {
-            Log.w(TAG, "mAdapter not found");
-            return;
-
-        }
-        // Get the header
-        Header header = (Header) mAdapter.getItem(position);
-        if (header == null) {
-            Log.w(TAG, "Header not found for position " + position);
-            return;
-        }
-        Bundle b = header.extras;
-        if (b == null) {
-            Log.w(TAG, "Bundle not found for position " + position);
-            return;
-        }
-
-        // fixme -- integrate into existing profile framework
-        String deviceMode = b.getString(EXTRA_DEVICE_MODE);
-
-        if (deviceMode != null)
-        {
-            HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(position);
-            if (viewHolder == null) {
-                Log.w(TAG, "ViewHolder not found for position " + position);
-                return;
-            }
-            final CompoundButton cpButton = viewHolder.switch_;
-            if (cpButton == null) {
-                Log.w(TAG, "Button not found for position " + position);
-                return;
-            }
-            final TextView tv_title = viewHolder.title;
-           if (tv_title == null) {
-               Log.w(TAG, "Title not found for position " + position);
-               return;
-           }
-            if(isChecked) {
-                setDeviceMode(deviceMode,isChecked,mService.DEFAULT_MODE);
-                tv_title.setClickable(false);
-            } else {
-                setDeviceMode(deviceMode,isChecked,mService.HEADSET_MODE);
-                tv_title.setClickable(false);
-           }
-            //cpButton.setEnabled(false);
-
-
-            return;
-        }
-
-        String profileName = b.getString(EXTRA_PROFILE_NAME);
-        if (profileName == null) {
-            Log.w(TAG, "Profile name not found for position " + position);
-            return;
-        }
-
-        Log.d(TAG, "onCheckChanged: profileName=" + profileName + ", isChecked=" + isChecked);
-        HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(position);
-        if (viewHolder == null) {
-            Log.w(TAG, "ViewHolder not found for position " + position);
-            return;
-        }
-        Button button = viewHolder.switch_;
-        if (button == null) {
-            Log.w(TAG, "Button not found for position " + position);
-            return;
-        }
-        //button.setEnabled(false);
-        setProfileState(profileName, isChecked);
-    }
-
-  /**
-     * Save the  device mode  (DEFAULT or HEADSET)
-     *
-     * @param on
-     * @return
-     */
-    public static void saveDeviceModeSetting(String deviceModeName, boolean enabled) {
-        if (mContext != null) {
-            ContentResolver cr = mContext.getContentResolver();
-            Settings.Global.putInt(cr, SETTINGS_PREFIX + deviceModeName, enabled ? 1 : 0);
-        }
-    }
-    //The default device mode displayed should be "TV".Content Resolver will be be NULL
-    //initially.
-    public static boolean isDeviceModeEnabled(String deviceModeName) {
-        boolean ret = true;
-        if (mContext != null) {
-            ContentResolver cr = mContext.getContentResolver();
-            try {
-                Log.d(TAG, "getProfileSaveSetting: " + deviceModeName);
-                if( Settings.Global.getInt(cr, SETTINGS_PREFIX + deviceModeName) != 1)
-                    ret = false;
-            } catch (Throwable t) {
-                Log.d(TAG, "Unable to read settings", t);
-            }
-        }
-        return ret;
-    }
-
-    @Override
-    public void onDeviceModeSwitchComplete() {
-
-        Log.w(TAG, "onDeviceModeSwitchComplete()");
-
-        isDeviceModeSwitchInProgress = false;
-        if (mAdapter == null) {
-            Log.w(TAG, "onDeviceModeSwitchComplete(): mAdapter not found");
-            return;
-        }
-
-        int count = mAdapter.getCount();
-        for (int i = 0; i < count; i++) {
-            Header header = (Header) mAdapter.getItem(i);
-            String name = null;
-            if (header != null && header.extras != null
-                    && (name = header.extras.getString(EXTRA_DEVICE_MODE)) != null) {
-                HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
-                if (viewHolder != null && viewHolder.switch_ != null) {
-                    final CompoundButton button = viewHolder.switch_;
-                    runOnUiThread(new Runnable() {
-                        @Override
-                        public void run() {
-                            //button.setEnabled(true);
-                            //button.refreshDrawableState();
-                            mAdapter.notifyDataSetChanged();
-                        }
-                    });
-                }
-            }
-        }
-    }
-
-    @Override
-    public void onProfileStateChanged(final String profileName, final int newState,
-            final int oldState) {
-        if (mAdapter == null) {
-            Log.w(TAG, "onProfileStateChanged(): mAdapter not found");
-            return;
-        }
-        int count = mAdapter.getCount();
-        for (int i = 0; i < count; i++) {
-            Header header = (Header) mAdapter.getItem(i);
-            String name = null;
-            if (header != null && header.extras != null
-                    && (name = header.extras.getString(EXTRA_PROFILE_NAME)) != null
-                    && name.equals(profileName)) {
-                HeaderViewHolder viewHolder = mAdapter.getHeaderViewHolder(i);
-                if (viewHolder != null && viewHolder.switch_ != null) {
-                    final CompoundButton button = viewHolder.switch_;
-                    runOnUiThread(new Runnable() {
-
-                        @Override
-                        public void run() {
-                            boolean checked = (newState == BluetoothAdapter.STATE_ON);
-                            if (checked != button.isChecked()) {
-                                button.setOnCheckedChangeListener(null);
-                                button.setChecked(checked);
-                                button.setOnCheckedChangeListener(mAdapter);
-                            }
-                            //button.setEnabled(true);
-                        }
-                    });
-                }
-            }
-        }
-    }
-}
-
-
diff --git a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/HeaderAdapter.java b/packages/apps/Bluetooth/src/com/broadcom/bt/settings/HeaderAdapter.java
deleted file mode 100644
index 02d47aa..0000000
--- a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/HeaderAdapter.java
+++ /dev/null
@@ -1,237 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2012-2013 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.settings;
-
-import java.util.List;
-
-import android.content.Context;
-import android.preference.PreferenceActivity.Header;
-import android.text.TextUtils;
-import android.util.Log;
-import android.util.SparseArray;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.CompoundButton;
-import android.widget.ImageView;
-import android.widget.Switch;
-import android.widget.TextView;
-import android.view.View.OnClickListener;
-
-import com.android.bluetooth.R;
-
-public abstract class HeaderAdapter extends ArrayAdapter<Header> implements
-        CompoundButton.OnCheckedChangeListener {
-    private static final String TAG="BtSettings.HeaderAdapter";
-    static final int HEADER_TYPE_CATEGORY = 0;
-    static final int HEADER_TYPE_NORMAL = 1;
-    static final int HEADER_TYPE_SWITCH = 2;
-    private static final int HEADER_TYPE_COUNT = HEADER_TYPE_SWITCH + 1;
-	private Switch mSwitch;
-
-    public static interface OnCheckedChangeListener {
-        public void onCheckedChanged(int position, boolean isChecked);
-    }
-
-    public static class HeaderViewHolder {
-        public ImageView icon;
-        public TextView title;
-        public TextView summary;
-        public Switch switch_;
-    }
-
-    private LayoutInflater mInflater;
-
-
-    private SparseArray<HeaderViewHolder> mHeaderViews =
-                          new SparseArray<HeaderAdapter.HeaderViewHolder>();
-
-    public HeaderViewHolder getHeaderViewHolder(int pos) {
-        return mHeaderViews.get(pos);
-    }
-
-    protected void setHeaderViewHolder(int pos, HeaderViewHolder h) {
-        mHeaderViews.put(pos, h);
-    }
-
-    protected abstract int getHeaderType(Header header);
-
-    protected abstract int getHeaderLayoutResId(int headerType);
-
-    protected abstract boolean getSwitchState(Header header);
-
-    @Override
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        Log.d(TAG, "onCheckChanged: isChecked = " + isChecked);
-        Log.d(TAG, "view=" + buttonView);
-
-        if (mCheckedChangeListener != null) {
-            Integer switchPosition = (Integer) buttonView.getTag();
-            Log.d(TAG, "SwitchPosition = " + switchPosition);
-            if (switchPosition != null) {
-                mCheckedChangeListener.onCheckedChanged(switchPosition, isChecked);
-            }
-        }
-    }
-
-    @Override
-    public int getItemViewType(int position) {
-        Header header = getItem(position);
-        return getHeaderType(header);
-    }
-
-    @Override
-    public boolean areAllItemsEnabled() {
-        return false; // because of categories
-    }
-
-    @Override
-    public boolean isEnabled(int position) {
-        return getItemViewType(position) != HEADER_TYPE_CATEGORY;
-    }
-
-    @Override
-    public int getViewTypeCount() {
-        return HEADER_TYPE_COUNT;
-    }
-
-    @Override
-    public boolean hasStableIds() {
-        return true;
-    }
-
-    private OnCheckedChangeListener mCheckedChangeListener;
-
-    public void setCheckedChangeListener(OnCheckedChangeListener listener) {
-        mCheckedChangeListener = listener;
-    }
-
-    public HeaderAdapter(Context context, List<Header> objects) {
-        super(context, 0, objects);
-        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-
-        Header header = getItem(position);
-        int headerType = getHeaderType(header);
-        View view = null;
-        Log.d(TAG, "getView(): position = " + position + ", convertView = "
-                + convertView);
-
-        HeaderViewHolder holder = getHeaderViewHolder(position);
-        if (holder == null) {
-            holder = new HeaderViewHolder();
-            setHeaderViewHolder(position, holder);
-        }
-
-        if (convertView == null) {
-            switch (headerType) {
-            case HEADER_TYPE_CATEGORY:
-                view = new TextView(getContext(), null, android.R.attr.listSeparatorTextViewStyle);
-                break;
-            case HEADER_TYPE_SWITCH:
-                view = mInflater.inflate(getHeaderLayoutResId(headerType), parent, false);
-                break;
-            case HEADER_TYPE_NORMAL:
-                view = mInflater.inflate(getHeaderLayoutResId(headerType), parent, false);
-                break;
-            }
-        } else {
-            view = convertView;
-        }
-
-        Log.d(TAG, "view=" + view);
-        // All view fields must be updated every time, because the view may be
-        // recycled
-        switch (headerType) {
-        case HEADER_TYPE_CATEGORY:
-            holder.title = (TextView) view;
-            holder.title.setText(header.getTitle(getContext().getResources()));
-            break;
-
-        case HEADER_TYPE_SWITCH:
-            mSwitch = holder.switch_ = (Switch) view.findViewById(R.id.switchWidget);
-            // No break, fall through on purpose to update common fields
-            boolean isChecked = getSwitchState(header);
-            holder.switch_.setOnCheckedChangeListener(null);
-            holder.switch_.setTag(position);
-            holder.switch_.setChecked(isChecked);
-            holder.switch_.setOnCheckedChangeListener(this);
-			holder.switch_.setOnClickListener(new OnClickListener() {
-				@Override
-				public void onClick(View v) {
-					// TODO Auto-generated method stub
-					Log.d(TAG, "switch onClick View="+v+" mSwitch="+mSwitch);
-					if (mSwitch != null) {
-						mSwitch.setClickable(false);
-						mSwitch.setEnabled(false);
-					}
-				}
-			});
-            //$FALL-THROUGH$
-        case HEADER_TYPE_NORMAL:
-            // holder.icon = (ImageView) view.findViewById(R.id.icon);
-            holder.title = (TextView) view.findViewById(com.android.internal.R.id.title);
-            holder.summary = (TextView) view.findViewById(com.android.internal.R.id.summary);
-            // holder.icon.setImageResource(header.iconRes);
-            holder.title.setText(header.getTitle(getContext().getResources()));
-            CharSequence summary = header.getSummary(getContext().getResources());
-            if (!TextUtils.isEmpty(summary)) {
-                holder.summary.setVisibility(View.VISIBLE);
-                holder.summary.setText(summary);
-            } else {
-                holder.summary.setVisibility(View.GONE);
-            }
-            break;
-        }
-        return view;
-    }
-
-}
diff --git a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/ModeAdvancedSettings.java b/packages/apps/Bluetooth/src/com/broadcom/bt/settings/ModeAdvancedSettings.java
deleted file mode 100644
index b72e535..0000000
--- a/packages/apps/Bluetooth/src/com/broadcom/bt/settings/ModeAdvancedSettings.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2013 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.service.settings;
-
-import com.android.bluetooth.R;
-import android.app.Fragment;
-import android.os.Bundle;
-import android.util.Log;
-
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-
-public class ModeAdvancedSettings extends Fragment {
-    private static final String TAG = "ModeAdvancedSettings";
-    public static final String SHARED_PREFERENCE_NAME = "ModeSharedPreferences";
-
-    public void onCreate(Bundle b) {
-        super.onCreate(b);
-    }
-        @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-       return null;
-    }
-}
diff --git a/packages/apps/Settings/res/values/strings.xml b/packages/apps/Settings/res/values/strings.xml
index 3188b3b..6152868 100644
--- a/packages/apps/Settings/res/values/strings.xml
+++ b/packages/apps/Settings/res/values/strings.xml
@@ -25,8 +25,6 @@
     <!-- Strings for Dialog deny button -->
     <string name="deny">Deny</string>
 
-    <string name="bluetooth_advanced_settings">Advanced Settings</string>
-
     <!-- Strings for Dialog close button [CHAR LIMIT=20] -->
     <string name="dlg_close">Close</string>
     <!-- Strings for Dialog switch button [CHAR LIMIT=20] -->
diff --git a/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java b/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java
index cbf8562..03f9d4d 100644
--- a/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java
+++ b/packages/apps/Settings/src/com/android/settings/bluetooth/BluetoothSettings.java
@@ -226,10 +226,6 @@ public final class BluetoothSettings extends DeviceListPreferenceFragment implem
                 .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
         menu.add(Menu.NONE, MENU_ID_SHOW_RECEIVED, 0, R.string.bluetooth_show_received_files)
                 .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
-        //Broadcom enhancement: advanced settings
-        com.broadcom.bt.app.settings.AdvancedSettings.addAdvancedSettingsMenu(getActivity(),
-                                                menu,bluetoothIsEnabled);
-        //Broadcom enhancement: advanced settings
         super.onCreateOptionsMenu(menu, inflater);
     }
 
@@ -255,12 +251,6 @@ public final class BluetoothSettings extends DeviceListPreferenceFragment implem
                 getActivity().sendBroadcast(intent);
                 return true;
         }
-        //Broadcom enhancement: advanced settings
-        if (com.broadcom.bt.app.settings.AdvancedSettings
-                .handleOptionsItemSelected(getActivity(), item)) {
-            return true;
-        }
-        //Broadcom enhancement: advanced settings
         return super.onOptionsItemSelected(item);
     }
 
diff --git a/packages/apps/Settings/src/com/broadcom/bt/app/settings/AdvancedSettings.java b/packages/apps/Settings/src/com/broadcom/bt/app/settings/AdvancedSettings.java
deleted file mode 100644
index 51be336..0000000
--- a/packages/apps/Settings/src/com/broadcom/bt/app/settings/AdvancedSettings.java
+++ /dev/null
@@ -1,86 +0,0 @@
-/*******************************************************************************
- *
- *  Copyright (C) 2012-2013 Broadcom Corporation
- *
- *  This program is the proprietary software of Broadcom Corporation and/or its
- *  licensors, and may only be used, duplicated, modified or distributed
- *  pursuant to the terms and conditions of a separate, written license
- *  agreement executed between you and Broadcom (an "Authorized License").
- *  Except as set forth in an Authorized License, Broadcom grants no license
- *  (express or implied), right to use, or waiver of any kind with respect to
- *  the Software, and Broadcom expressly reserves all rights in and to the
- *  Software and all intellectual property rights therein.
- *  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS
- *  SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE
- *  ALL USE OF THE SOFTWARE.
- *
- *  Except as expressly set forth in the Authorized License,
- *
- *  1.     This program, including its structure, sequence and organization,
- *         constitutes the valuable trade secrets of Broadcom, and you shall
- *         use all reasonable efforts to protect the confidentiality thereof,
- *         and to use this information only in connection with your use of
- *         Broadcom integrated circuit products.
- *
- *  2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED
- *         "AS IS" AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES,
- *         REPRESENTATIONS OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY,
- *         OR OTHERWISE, WITH RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY
- *         DISCLAIMS ANY AND ALL IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY,
- *         NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF VIRUSES,
- *         ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
- *         CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT
- *         OF USE OR PERFORMANCE OF THE SOFTWARE.
- *
- *  3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR
- *         ITS LICENSORS BE LIABLE FOR
- *         (i)   CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR EXEMPLARY
- *               DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
- *               YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM
- *               HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR
- *         (ii)  ANY AMOUNT IN EXCESS OF THE AMOUNT ACTUALLY PAID FOR THE
- *               SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE
- *               LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
- *               ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
- *
- *******************************************************************************/
-package com.broadcom.bt.app.settings;
-
-import android.app.Activity;
-import android.content.Intent;
-import android.content.res.Resources;
-import android.view.Menu;
-import android.view.MenuItem;
-
-public class AdvancedSettings {
-    public static final int MENU_ID_ADVANCED_SETTINGS = 1000;
-
-    public static void addAdvancedSettingsMenu(Activity activity, Menu menu,
-                                boolean bluetoothIsEnabled ) {
-        if (activity == null) {
-            return;
-        }
-        //Resources r = activity.getResources();
-        //boolean includeAdvancedSettings = r
-        //        .getBoolean(com.android.settings.R.bool.supports_advanced_settings);
-        if (true/*includeAdvancedSettings*/) {
-            menu.add(Menu.NONE, MENU_ID_ADVANCED_SETTINGS, 0,
-                    com.android.settings.R.string.bluetooth_advanced_settings)
-                    .setEnabled(bluetoothIsEnabled)
-                    .setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
-        }
-    }
-
-    public static boolean handleOptionsItemSelected(Activity activity,
-            MenuItem item) {
-        if (activity == null || item == null
-                || item.getItemId() != MENU_ID_ADVANCED_SETTINGS) {
-            return false;
-        }
-        Intent intent = new Intent();
-        intent.setClassName("com.android.bluetooth",
-                "com.broadcom.bt.settings.BluetoothAdvancedSettings");
-        activity.startActivity(intent);
-        return true;
-    }
-}
diff --git a/system/bt/audio_a2dp_hw/audio_a2dp_hw.c b/system/bt/audio_a2dp_hw/audio_a2dp_hw.c
index 0a69ac9..66a5780 100755
--- a/system/bt/audio_a2dp_hw/audio_a2dp_hw.c
+++ b/system/bt/audio_a2dp_hw/audio_a2dp_hw.c
@@ -58,26 +58,13 @@ static bool gIsSave = false;
 **  Constants & Macros
 ******************************************************************************/
 
-// Don't restrict socket size for sink to minimize blocking reads that
-// can cause unnecessary timing variations in audioframework threads.
-// Socket queue level is managed by stack library (jbuf.c) via a2dp_calibrate_queue.
-// 0 means disabling setting socket size when establishing the sockets.
-static const size_t A2DP_INPUT_SKT_RECV_SZ = 0;
-
-// To minimize read rate transients during initial setup of audioflinger read threads
-// we prefill the socket pipe and then open up the audio flow.
-// 6 K is equivalent to around 35 ms of audio @44.1 khz which provides a good
-// compromise between the read burstiness of the audioflinger read threads and
-// keeping latency down.
-static const int AVK_PRELOAD_SZ = 1024*6;
 #define CTRL_CHAN_RETRY_COUNT 3
 #define USEC_PER_SEC 1000000L
 
-static const char* A2DP_FORCE_SUSPENDED = "A2dpSuspended";
 #define CASE_RETURN_STR(const) case const: return #const;
 
 #define FNLOG()             LOG_VERBOSE("%s", __FUNCTION__);
-#define DEBUG(fmt, ...)     LOG_DEBUG("%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
+#define DEBUG(fmt, ...)     LOG_VERBOSE("%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
 #define INFO(fmt, ...)      LOG_INFO("%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
 #define ERROR(fmt, ...)     LOG_ERROR("%s: " fmt,__FUNCTION__, ## __VA_ARGS__)
 
@@ -125,14 +112,13 @@ struct a2dp_stream_common {
 struct a2dp_stream_out {
     struct audio_stream_out stream;
     struct a2dp_stream_common common;
+    uint64_t frames_presented; // frames written, never reset
+    uint64_t frames_rendered;  // frames written, reset on standby
 };
 
 struct a2dp_stream_in {
     struct audio_stream_in  stream;
     struct a2dp_stream_common common;
-    unsigned int poll_timeout_ms;
-    bool preload_active; // used to fill socket pipe before opening flow
-    char *buffer;
 };
 
 /*****************************************************************************
@@ -166,8 +152,6 @@ static const char* dump_a2dp_ctrl_event(char event)
         CASE_RETURN_STR(A2DP_CTRL_CMD_START)
         CASE_RETURN_STR(A2DP_CTRL_CMD_STOP)
         CASE_RETURN_STR(A2DP_CTRL_CMD_SUSPEND)
-        CASE_RETURN_STR(A2DP_CTRL_GET_AUDIO_CONFIG)
-        CASE_RETURN_STR(A2DP_CTRL_CMD_CALIBRATE)
         default:
             return "UNKNOWN MSG ID";
     }
@@ -218,7 +202,7 @@ static int calc_audiotime(struct a2dp_config cfg, int bytes)
 **
 *****************************************************************************/
 
-static int skt_connect(const char *path, size_t buffer_sz)
+static int skt_connect(char *path, size_t buffer_sz)
 {
     int ret;
     int skt_fd;
@@ -237,8 +221,6 @@ static int skt_connect(const char *path, size_t buffer_sz)
         return -1;
     }
 
-    if (buffer_sz > 0)
-    {
     len = buffer_sz;
     ret = setsockopt(skt_fd, SOL_SOCKET, SO_SNDBUF, (char*)&len, (int)sizeof(len));
 
@@ -251,7 +233,6 @@ static int skt_connect(const char *path, size_t buffer_sz)
     /* only issue warning if failed */
     if (ret < 0)
         ERROR("setsockopt failed (%s)", strerror(errno));
-    }
 
     INFO("connected to stack fd = %d", skt_fd);
 
@@ -418,16 +399,15 @@ static int a2dp_read_audio_config(struct a2dp_stream_common *common)
     return 0;
 }
 
-static void a2dp_open_ctrl_path(struct a2dp_stream_common *common, bool is_output)
+static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
 {
     int i;
-    const char *path = is_output ? A2DP_CTRL_PATH : A2DP_SINK_CTRL_PATH;
 
     /* retry logic to catch any timing variations on control channel */
     for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)
     {
-        // connect control channel if not already connected
-        if ((common->ctrl_fd = skt_connect(path, 0)) > 0)
+        /* connect control channel if not already connected */
+        if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
         {
             /* success, now check if stack is ready */
             if (check_a2dp_ready(common) == 0)
@@ -468,7 +448,7 @@ static void a2dp_stream_common_init(struct a2dp_stream_common *common)
     common->buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;
 }
 
-static int start_audio_datapath(struct a2dp_stream_common *common, bool is_output)
+static int start_audio_datapath(struct a2dp_stream_common *common)
 {
     INFO("state %d", common->state);
 
@@ -498,16 +478,7 @@ static int start_audio_datapath(struct a2dp_stream_common *common, bool is_outpu
     /* connect socket if not yet connected */
     if (common->audio_fd == AUDIO_SKT_DISCONNECTED)
     {
-        const char *path = A2DP_SINK_DATA_PATH;
-        int buffer_sz = A2DP_INPUT_SKT_RECV_SZ;
-
-        if (is_output)
-        {
-            path = A2DP_DATA_PATH;
-            buffer_sz = common->buffer_sz;
-        }
-
-        common->audio_fd = skt_connect(path, buffer_sz);
+        common->audio_fd = skt_connect(A2DP_DATA_PATH, common->buffer_sz);
         if (common->audio_fd < 0)
         {
             common->state = oldstate;
@@ -603,7 +574,7 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
     if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||
         (out->common.state == AUDIO_A2DP_STATE_STANDBY))
     {
-        if (start_audio_datapath(&out->common, true) < 0)
+        if (start_audio_datapath(&out->common) < 0)
         {
             /* emulate time this write represents to avoid very fast write
                failures during transition periods or remote suspend */
@@ -663,14 +634,17 @@ static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
 
     sent = skt_write(out->common.audio_fd, buffer,  bytes);
 
-    if (sent == -1)
-    {
+    if (sent == -1) {
         skt_disconnect(out->common.audio_fd);
         out->common.audio_fd = AUDIO_SKT_DISCONNECTED;
         if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
             out->common.state = AUDIO_A2DP_STATE_STOPPED;
         else
             ERROR("write failed : stream suspended, avoid resetting state");
+    } else {
+        const size_t frames = bytes / audio_stream_out_frame_size(stream);
+        out->frames_rendered += frames;
+        out->frames_presented += frames;
     }
 
     DEBUG("wrote %d bytes out of %zu bytes", sent, bytes);
@@ -748,6 +722,7 @@ static int out_standby(struct audio_stream *stream)
     // Do nothing in SUSPENDED state.
     if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
         retVal = suspend_audio_datapath(&out->common, true);
+    out->frames_rendered = 0; // rendered is reset, presented is not
     pthread_mutex_unlock (&out->common.lock);
 
     return retVal;
@@ -858,16 +833,45 @@ static int out_set_volume(struct audio_stream_out *stream, float left,
     return -ENOSYS;
 }
 
+static int out_get_presentation_position(const struct audio_stream_out *stream,
+                                         uint64_t *frames, struct timespec *timestamp)
+{
+    struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
+
+    FNLOG();
+    if (stream == NULL || frames == NULL || timestamp == NULL)
+        return -EINVAL;
 
+    int ret = -EWOULDBLOCK;
+    pthread_mutex_lock(&out->common.lock);
+    uint64_t latency_frames = (uint64_t)out_get_latency(stream) * out->common.cfg.rate / 1000;
+    if (out->frames_presented >= latency_frames) {
+        *frames = out->frames_presented - latency_frames;
+        clock_gettime(CLOCK_MONOTONIC, timestamp); // could also be associated with out_write().
+        ret = 0;
+    }
+    pthread_mutex_unlock(&out->common.lock);
+    return ret;
+}
 
 static int out_get_render_position(const struct audio_stream_out *stream,
                                    uint32_t *dsp_frames)
 {
-    UNUSED(stream);
-    UNUSED(dsp_frames);
+    struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 
     FNLOG();
-    return -EINVAL;
+    if (stream == NULL || dsp_frames == NULL)
+        return -EINVAL;
+
+    pthread_mutex_lock(&out->common.lock);
+    uint64_t latency_frames = (uint64_t)out_get_latency(stream) * out->common.cfg.rate / 1000;
+    if (out->frames_rendered >= latency_frames) {
+        *dsp_frames = (uint32_t)(out->frames_rendered - latency_frames);
+    } else {
+        *dsp_frames = 0;
+    }
+    pthread_mutex_unlock(&out->common.lock);
+    return 0;
 }
 
 static int out_add_audio_effect(const struct audio_stream *stream, effect_handle_t effect)
@@ -896,7 +900,7 @@ static uint32_t in_get_sample_rate(const struct audio_stream *stream)
 {
     struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
 
-    DEBUG("%s rate %d", __func__, in->common.cfg.rate);
+    FNLOG();
     return in->common.cfg.rate;
 }
 
@@ -914,11 +918,10 @@ static int in_set_sample_rate(struct audio_stream *stream, uint32_t rate)
 
 static size_t in_get_buffer_size(const struct audio_stream *stream)
 {
-    const struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
-
-    DEBUG("buffer_size : %d", in->common.buffer_sz);
+    UNUSED(stream);
 
-    return in->common.buffer_sz;
+    FNLOG();
+    return 320;
 }
 
 static uint32_t in_get_channels(const struct audio_stream *stream)
@@ -968,75 +971,20 @@ static int in_dump(const struct audio_stream *stream, int fd)
 
 static int in_set_parameters(struct audio_stream *stream, const char *kvpairs)
 {
-    struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
-    struct str_parms *params;
-
-    INFO("state %d %s", in->common.state, kvpairs);
-
-    params = str_parms_create_str(kvpairs);
-
-    //str_parms_dump(params);
-
-    char keyval[16];
-    int retval = 0;
-    retval = str_parms_get_str(params, A2DP_FORCE_SUSPENDED, keyval, sizeof(keyval));
-
-    if (retval < 0) {
-        ERROR("parameter not recognized");
-        retval = 0;
-        goto done;
-    }
-
-    // Use control channel to inform stack of manual suspension state
-    if (strcmp(keyval, "true") == 0)
-    {
-       if (in->common.state == AUDIO_A2DP_STATE_STARTED)
-       {
-           INFO("force suspend input");
-           retval = suspend_audio_datapath(&in->common, false);
-       }
-    }
-    else if (strcmp(keyval, "false") == 0)
-    {
-        INFO("resuming force suspended input");
-        if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)
-        {
-            in->common.state = AUDIO_A2DP_STATE_STANDBY;
-            retval = start_audio_datapath(&in->common, false);
-        }
-    }
-    else
-    {
-        ERROR("invalid setting");
-        retval = -1;
-    }
+    UNUSED(stream);
+    UNUSED(kvpairs);
 
-done :
-    str_parms_destroy(params);
-    return retval;
+    FNLOG();
+    return 0;
 }
 
 static char * in_get_parameters(const struct audio_stream *stream,
                                 const char *keys)
 {
     UNUSED(stream);
-    char *str = strdup(keys);
-    char *tmpstr;
-
-    char *keystr = strtok_r(str, ";", &tmpstr);
-    while (keystr && *keystr)
-    {
-        // If the key string is FastCaptureDefeat respond that we want to do this.
-        if (strcmp(keystr,"FastCaptureDefeat") == 0)
-        {
-            free(str);
-            return strdup("true");
-        }
-
-        keystr = strtok_r(NULL, ";", &tmpstr);
-    }
+    UNUSED(keys);
 
-    free(str);
+    FNLOG();
     return strdup("");
 }
 
@@ -1069,7 +1017,7 @@ static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
     {
         pthread_mutex_lock(&in->common.lock);
 
-        if (start_audio_datapath(&in->common, false) < 0)
+        if (start_audio_datapath(&in->common) < 0)
         {
             /* emulate time this write represents to avoid very fast write
                failures during transition periods or remote suspend */
@@ -1176,6 +1124,8 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     out->stream.set_volume = out_set_volume;
     out->stream.write = out_write;
     out->stream.get_render_position = out_get_render_position;
+    out->stream.get_presentation_position = out_get_presentation_position;
+
 
     /* initialize a2dp specifics */
     a2dp_stream_common_init(&out->common);
@@ -1184,10 +1134,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     out->common.cfg.format = AUDIO_STREAM_DEFAULT_FORMAT;
     out->common.cfg.rate = AUDIO_STREAM_DEFAULT_RATE;
 
-    // manages max capacity of socket pipe
-    out->common.buffer_sz = AUDIO_STREAM_OUTPUT_BUFFER_SZ;
-
-   // set output config values
+   /* set output config values */
    if (config)
    {
       config->format = out_get_format((const struct audio_stream *)&out->stream);
@@ -1197,7 +1144,7 @@ static int adev_open_output_stream(struct audio_hw_device *dev,
     *stream_out = &out->stream;
     a2dp_dev->output = out;
 
-    a2dp_open_ctrl_path(&out->common, true);
+    a2dp_open_ctrl_path(&out->common);
     if (out->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
     {
         ERROR("ctrl socket failed to connect (%s)", strerror(errno));
@@ -1253,19 +1200,15 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
 {
     struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device *)dev;
     struct a2dp_stream_out *out = a2dp_dev->output;
-    struct a2dp_stream_in *in = a2dp_dev->input;
     int retval = 0;
 
-    if (in != NULL)
-    {
-        DEBUG("state %d", in->common.state);
-        retval = in->stream.common.set_parameters((struct audio_stream *)in, kvpairs);
-    }
-    else if (out != NULL)
-    {
-        DEBUG("state %d", out->common.state);
-		retval = out->stream.common.set_parameters((struct audio_stream *)out, kvpairs);
-    }
+    if (out == NULL)
+        return retval;
+
+    INFO("state %d", out->common.state);
+
+    retval = out->stream.common.set_parameters((struct audio_stream *)out, kvpairs);
+
     return retval;
 }
 
@@ -1288,8 +1231,10 @@ static char * adev_get_parameters(const struct audio_hw_device *dev,
 
 static int adev_init_check(const struct audio_hw_device *dev)
 {
-    UNUSED(dev);
+    struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device*)dev;
+
     FNLOG();
+
     return 0;
 }
 
@@ -1346,12 +1291,12 @@ static int adev_get_mic_mute(const struct audio_hw_device *dev, bool *state)
 static size_t adev_get_input_buffer_size(const struct audio_hw_device *dev,
                                          const struct audio_config *config)
 {
+    UNUSED(dev);
     UNUSED(config);
 
-    struct a2dp_audio_device *a2dp_dev = (struct a2dp_audio_device*)dev;
     FNLOG();
 
-    return in_get_buffer_size((struct audio_stream*)a2dp_dev->input);
+    return 320;
 }
 
 static int adev_open_input_stream(struct audio_hw_device *dev,
@@ -1399,13 +1344,10 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
     /* initialize a2dp specifics */
     a2dp_stream_common_init(&in->common);
 
-    // manages max capacity of socket pipe
-    in->common.buffer_sz = AUDIO_STREAM_INPUT_BUFFER_SZ;
-    in->poll_timeout_ms = AUDIO_STREAM_INPUT_POLL_TMO_MS;
     *stream_in = &in->stream;
     a2dp_dev->input = in;
 
-    a2dp_open_ctrl_path(&in->common, false);
+    a2dp_open_ctrl_path(&in->common);
     if (in->common.ctrl_fd == AUDIO_SKT_DISCONNECTED)
     {
         ERROR("ctrl socket failed to connect (%s)", strerror(errno));
@@ -1419,16 +1361,6 @@ static int adev_open_input_stream(struct audio_hw_device *dev,
         goto err_open;
     }
 
-    if (in->common.cfg.channel_flags == AUDIO_CHANNEL_IN_MONO)
-    {
-        // Need to create a temp buffer to load initial mono data into
-        in->buffer = (char *)malloc(in->common.buffer_sz);
-        if (in->buffer == NULL)
-        {
-            ret = -1;
-            goto err_open;
-        }
-    }
     DEBUG("success");
     return 0;
 
@@ -1519,7 +1451,6 @@ static int adev_open(const hw_module_t* module, const char* name,
 
     adev->output = NULL;
 
-    adev->input  = NULL;
 
     *device = &adev->device.common;
 
diff --git a/system/bt/audio_a2dp_hw/audio_a2dp_hw.h b/system/bt/audio_a2dp_hw/audio_a2dp_hw.h
old mode 100755
new mode 100644
index e4933de..1e9464c
--- a/system/bt/audio_a2dp_hw/audio_a2dp_hw.h
+++ b/system/bt/audio_a2dp_hw/audio_a2dp_hw.h
@@ -35,21 +35,10 @@
 #define A2DP_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
 #define A2DP_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
 
-#define A2DP_SINK_CTRL_PATH "/data/misc/bluedroid/.a2dp_ctrl"
-#define A2DP_SINK_DATA_PATH "/data/misc/bluedroid/.a2dp_data"
-//#define A2DP_SINK_CTRL_PATH "/data/misc/bluedroid/.a2dp_sink_ctrl"
-//#define A2DP_SINK_DATA_PATH "/data/misc/bluedroid/.a2dp_sink_data"
-
-
-
 #define AUDIO_STREAM_DEFAULT_RATE          44100
 #define AUDIO_STREAM_DEFAULT_FORMAT        AUDIO_FORMAT_PCM_16_BIT
 #define AUDIO_STREAM_DEFAULT_CHANNEL_FLAG  AUDIO_CHANNEL_OUT_STEREO
-#define AUDIO_STREAM_DEFAULT_CHANNEL_IN_FLAG  AUDIO_CHANNEL_IN_STEREO
 #define AUDIO_STREAM_OUTPUT_BUFFER_SZ      (20*512)
-#define AUDIO_STREAM_INPUT_BUFFER_SZ       (512*2)
-
-#define AUDIO_STREAM_INPUT_POLL_TMO_MS     (80)
 #define AUDIO_SKT_DISCONNECTED             (-1)
 
 typedef enum {
@@ -59,7 +48,6 @@ typedef enum {
     A2DP_CTRL_CMD_STOP,
     A2DP_CTRL_CMD_SUSPEND,
     A2DP_CTRL_GET_AUDIO_CONFIG,
-    A2DP_CTRL_CMD_CALIBRATE
 } tA2DP_CTRL_CMD;
 
 typedef enum {
@@ -80,18 +68,7 @@ typedef enum {
 /*****************************************************************************
 **  Extern variables and functions
 ******************************************************************************/
-typedef struct a2dp_codec_config {
-    uint8_t channel_count;
-    unsigned int sample_frequency;
-} a2dp_codec_config_t;
-
-// Struct type used during calibration of socket queue depth
-typedef struct a2dp_calibrate {
-    uint8_t cmd;
-    uint8_t status;
-    int cur_skt_sz;
-    int calibrate;
-} a2dp_calibrate_t;
+
 /*****************************************************************************
 **  Functions
 ******************************************************************************/
diff --git a/system/bt/bta/av/bta_av_aact.c b/system/bt/bta/av/bta_av_aact.c
index e716973..73fe923 100644
--- a/system/bt/bta/av/bta_av_aact.c
+++ b/system/bt/bta/av/bta_av_aact.c
@@ -565,7 +565,6 @@ static void bta_av_proc_stream_evt(UINT8 handle, BD_ADDR bd_addr, UINT8 event, t
     }
     else
     {
-        APPL_TRACE_ERROR("event is: %d", event);
         APPL_TRACE_ERROR("%s: p_data is null", __func__);
     }
 }
diff --git a/system/bt/bta/av/bta_av_act.c b/system/bt/bta/av/bta_av_act.c
index f4321a8..75e0900 100644
--- a/system/bt/bta/av/bta_av_act.c
+++ b/system/bt/bta/av/bta_av_act.c
@@ -299,7 +299,6 @@ static void bta_av_rc_msg_cback(UINT8 handle, UINT8 label, UINT8 opcode, tAVRC_M
 ** Returns          the created rc handle
 **
 *******************************************************************************/
- extern UINT8 g_is_avk_av;
 UINT8 bta_av_rc_create(tBTA_AV_CB *p_cb, UINT8 role, UINT8 shdl, UINT8 lidx)
 {
     tAVRC_CONN_CB ccb;
@@ -329,14 +328,7 @@ UINT8 bta_av_rc_create(tBTA_AV_CB *p_cb, UINT8 role, UINT8 shdl, UINT8 lidx)
     ccb.company_id = p_bta_av_cfg->company_id;
     ccb.conn = role;
     /* note: BTA_AV_FEAT_RCTG = AVRC_CT_TARGET, BTA_AV_FEAT_RCCT = AVRC_CT_CONTROL */
-     if(!g_is_avk_av)
-     {
-            ccb.control = p_cb->features & (BTA_AV_FEAT_RCTG | AVRC_CT_PASSIVE);
-     }
-     else
-     {
-           ccb.control = p_cb->features & (BTA_AV_FEAT_RCCT | AVRC_CT_PASSIVE);
-     }
+    ccb.control = p_cb->features & (BTA_AV_FEAT_RCTG | BTA_AV_FEAT_RCCT | AVRC_CT_PASSIVE);
 
 
     if (AVRC_Open(&rc_handle, &ccb, bda) != AVRC_SUCCESS)
@@ -1705,7 +1697,6 @@ tBTA_AV_FEAT bta_av_check_peer_features (UINT16 service_uuid)
 ** Returns          void
 **
 *******************************************************************************/
-extern UINT8 g_is_avk_av;
 void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
 {
     tBTA_AV_CB   *p_cb = &bta_av_cb;
@@ -1794,15 +1785,6 @@ void bta_av_rc_disc_done(tBTA_AV_DATA *p_data)
     }
     else
     {
-	if((peer_features & BTA_AV_FEAT_RCTG)&&(!g_is_avk_av))
-	{
-           APPL_TRACE_DEBUG("oscar-->start close rc......");
-               
-	    AVRC_Close(rc_handle);
-            return;
-           //   btm_remove_acl(p_scb->peer_addr, BT_TRANSPORT_BR_EDR);
-	     //  return;
-	}
         p_cb->rcb[rc_handle].peer_features = peer_features;
         rc_feat.rc_handle =  rc_handle;
         rc_feat.peer_features = peer_features;
diff --git a/system/bt/bta/av/bta_av_main.c b/system/bt/bta/av/bta_av_main.c
index 4d144f2..9a40929 100644
--- a/system/bt/bta/av/bta_av_main.c
+++ b/system/bt/bta/av/bta_av_main.c
@@ -500,13 +500,8 @@ static void bta_av_a2dp_report_cback(UINT8 handle, AVDT_REPORT_TYPE type,
 **
 *******************************************************************************/
 
-
-extern UINT8 g_is_avk_av;
-
 static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
 {
-  if(g_is_avk_av)
-  {
     UINT16 activate_sink = 0;
     activate_sink = p_data->hdr.layer_specific;
     APPL_TRACE_DEBUG("bta_av_api_sink_enable %d ", activate_sink)
@@ -525,7 +520,6 @@ static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
             bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SINK);
         }
     }
-  }
     else
     {
         AVDT_SINK_Deactivate();
@@ -549,9 +543,6 @@ static void bta_av_api_sink_enable(tBTA_AV_DATA *p_data)
 ** Returns          void
 **
 *******************************************************************************/
-
-
-
 static void bta_av_api_register(tBTA_AV_DATA *p_data)
 {
     tBTA_AV_REGISTER    registr;
@@ -562,7 +553,6 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
     tBTA_AV_CODEC   codec_type;
     tBTA_UTL_COD    cod;
     UINT8           index = 0;
-
     char p_avk_service_name[BTA_SERVICE_NAME_LEN+1];
     BCM_STRNCPY_S(p_avk_service_name, sizeof(p_avk_service_name), BTIF_AVK_SERVICE_NAME, BTA_SERVICE_NAME_LEN);
 
@@ -620,12 +610,7 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
 
             /* Set the Capturing service class bit */
 #if (BTA_AV_SINK_INCLUDED == TRUE)
-       if(g_is_avk_av)  //oscar
-       {
             cod.service = BTM_COD_SERVICE_CAPTURING | BTM_COD_SERVICE_RENDERING;
-       }else {
-            cod.service = BTM_COD_SERVICE_CAPTURING;
-       }
 #else
             cod.service = BTM_COD_SERVICE_CAPTURING;
 #endif
@@ -690,14 +675,11 @@ static void bta_av_api_register(tBTA_AV_DATA *p_data)
             {
 
 #if (BTA_AV_SINK_INCLUDED == TRUE)
-if(g_is_avk_av)  //oscar
-{
             if(index == 1)
             {
                 cs.tsep = AVDT_TSEP_SNK;
                 cs.p_data_cback = bta_av_stream_data_cback;
             }
-}
                 APPL_TRACE_DEBUG(" SEP Type = %d",cs.tsep);
 #endif
                 if(AVDT_CreateStream(&p_scb->seps[index].av_handle, &cs) == AVDT_SUCCESS)
@@ -705,13 +687,9 @@ if(g_is_avk_av)  //oscar
                     p_scb->seps[index].codec_type = codec_type;
 
 #if (BTA_AV_SINK_INCLUDED == TRUE)
-
                     p_scb->seps[index].tsep = cs.tsep;
                     if(cs.tsep == AVDT_TSEP_SNK)
-                    {
-                       if(g_is_avk_av)  //oscar
                         p_scb->seps[index].p_app_data_cback = p_data->api_reg.p_app_data_cback;
-                    }
                     else
                         p_scb->seps[index].p_app_data_cback = NULL; /* In case of A2DP SOURCE we don't need a callback to handle media packets */
 #endif
@@ -733,14 +711,10 @@ if(g_is_avk_av)  //oscar
                 bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SOURCE);
 
 #if (BTA_AV_SINK_INCLUDED == TRUE)
-
-if(g_is_avk_av)  //oscar
-{
                 bta_av_cb.sdp_a2d_snk_handle = SDP_CreateRecord();
                 A2D_AddRecord(UUID_SERVCLASS_AUDIO_SINK, p_avk_service_name, NULL,
                                   A2D_SUPF_PLAYER, bta_av_cb.sdp_a2d_snk_handle);
                 bta_sys_add_uuid(UUID_SERVCLASS_AUDIO_SINK);
-}			
 #endif
                 /* start listening when A2DP is registered */
                 if (bta_av_cb.features & BTA_AV_FEAT_RCTG)
diff --git a/system/bt/btif/include/btif_av.h b/system/bt/btif/include/btif_av.h
index 48a78d6..cedc1b7 100644
--- a/system/bt/btif/include/btif_av.h
+++ b/system/bt/btif/include/btif_av.h
@@ -113,7 +113,6 @@ void btif_dispatch_sm_event(btif_av_sm_event_t event, void *p_data, int len);
 
 bt_status_t btif_av_init(void);
 
-
 /*******************************************************************************
 **
 ** Function         btif_av_is_connected
diff --git a/system/bt/btif/src/btif_av.c b/system/bt/btif/src/btif_av.c
index 1f1a506..5715748 100644
--- a/system/bt/btif/src/btif_av.c
+++ b/system/bt/btif/src/btif_av.c
@@ -299,9 +299,7 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data)
 
         case BTA_AV_PENDING_EVT:
         case BTIF_AV_CONNECT_REQ_EVT:
-        {    
-             bt_bdaddr_t* paddr;
-             paddr = ((btif_av_connect_req_t*)p_data)->target_bda;
+        {
              if (event == BTIF_AV_CONNECT_REQ_EVT)
              {
                  memcpy(&btif_av_cb.peer_bda, ((btif_av_connect_req_t*)p_data)->target_bda,
@@ -315,11 +313,6 @@ static BOOLEAN btif_av_state_idle_handler(btif_sm_event_t event, void *p_data)
                   BTA_AvOpen(btif_av_cb.peer_bda.address, btif_av_cb.bta_handle,
                     TRUE, BTA_SEC_AUTHENTICATE, UUID_SERVCLASS_AUDIO_SOURCE);
              }
-             if (paddr) {
-                 //BTIF_TRACE_DEBUG("peer_onnect addr=%02x:%02x:%02x, target_addr=%02x:%02x:%02x",
-                 //   btif_av_cb.peer_bda.address[0], btif_av_cb.peer_bda.address[1], btif_av_cb.peer_bda.address[2],
-                 //   paddr->address[0], paddr->address[1], paddr->address[2]);
-             }
              btif_sm_change_state(btif_av_cb.sm_handle, BTIF_AV_STATE_OPENING);
         } break;
 
@@ -452,7 +445,7 @@ static BOOLEAN btif_av_state_opening_handler(btif_sm_event_t event, void *p_data
 
             BTIF_TRACE_WARNING("BTIF_AV_SINK_CONFIG_REQ_EVT %d %d", req.sample_rate,
                     req.channel_count);
-            if (/*btif_av_cb.peer_sep == AVDT_TSEP_SRC &&*/ bt_av_sink_callbacks != NULL) {
+            if (btif_av_cb.peer_sep == AVDT_TSEP_SRC && bt_av_sink_callbacks != NULL) {
                 HAL_CBACK(bt_av_sink_callbacks, audio_config_cb, &(btif_av_cb.peer_bda),
                         req.sample_rate, req.channel_count);
             }
@@ -586,7 +579,6 @@ static BOOLEAN btif_av_state_closing_handler(btif_sm_event_t event, void *p_data
 static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data)
 {
     tBTA_AV *p_av = (tBTA_AV*)p_data;
-    bt_bdaddr_t *paddr;
 
     BTIF_TRACE_DEBUG("%s event:%s flags %x", __FUNCTION__,
                      dump_av_sm_event_name(event), btif_av_cb.flags);
@@ -707,7 +699,6 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data)
             break;
 
         case BTIF_AV_CONNECT_REQ_EVT:
-            paddr = (bt_bdaddr_t*)p_data;
             if (memcmp ((bt_bdaddr_t*)p_data, &(btif_av_cb.peer_bda),
                 sizeof(btif_av_cb.peer_bda)) == 0)
             {
@@ -715,9 +706,6 @@ static BOOLEAN btif_av_state_opened_handler(btif_sm_event_t event, void *p_data)
             }
             else
             {
-                BTIF_TRACE_DEBUG("connect addr=%02x:%02x:%02x, peer_addr=%02x:%02x:%02x",
-                    paddr->address[0], paddr->address[1], paddr->address[2],
-                    btif_av_cb.peer_bda.address[0], btif_av_cb.peer_bda.address[1], btif_av_cb.peer_bda.address[2]);
                 BTIF_TRACE_DEBUG("%s: Moved to opened by Other Incoming Conn req", __func__);
                 btif_report_connection_state(BTAV_CONNECTION_STATE_DISCONNECTED,
                         (bt_bdaddr_t*)p_data);
@@ -1031,12 +1019,6 @@ static void bte_av_media_callback(tBTA_AV_EVT event, tBTA_AV_MEDIA *p_data)
 **
 *******************************************************************************/
 
-//oscar++
-
-UINT8 g_is_avk_av=0;   // 0:av  1:avk
-
-//oscar--
-
 bt_status_t btif_av_init()
 {
     if (btif_av_cb.sm_handle == NULL)
@@ -1053,7 +1035,6 @@ bt_status_t btif_av_init()
         btif_enable_service(BTA_A2DP_SINK_SERVICE_ID);
 #endif
 
-
         btif_a2dp_on_init();
     }
 
@@ -1076,10 +1057,7 @@ static bt_status_t init_src(btav_callbacks_t* callbacks)
 
     bt_status_t status = btif_av_init();
     if (status == BT_STATUS_SUCCESS)
-    {
         bt_av_src_callbacks = callbacks;
-       g_is_avk_av=0;  //oscar
-    }
 
     return status;
 }
@@ -1098,8 +1076,6 @@ static bt_status_t init_sink(btav_callbacks_t* callbacks)
 {
     BTIF_TRACE_EVENT("%s()", __func__);
 
-    g_is_avk_av=1;  //oscar		
-    
     bt_status_t status = btif_av_init();
     if (status == BT_STATUS_SUCCESS)
         bt_av_sink_callbacks = callbacks;
@@ -1179,7 +1155,6 @@ static void cleanup(void)
     BTIF_TRACE_EVENT("%s", __FUNCTION__);
 
     btif_a2dp_stop_media_task();
-    
 
     btif_disable_service(BTA_A2DP_SOURCE_SERVICE_ID);
 #if (BTA_AV_SINK_INCLUDED == TRUE)
@@ -1188,7 +1163,6 @@ static void cleanup(void)
 
     /* Also shut down the AV state machine */
     btif_sm_shutdown(btif_av_cb.sm_handle);
-    memset(&btif_av_cb, 0, sizeof(btif_av_cb));
     btif_av_cb.sm_handle = NULL;
 }
 
@@ -1371,8 +1345,8 @@ bt_status_t btif_av_execute_service(BOOLEAN b_enable)
 *******************************************************************************/
 bt_status_t btif_av_sink_execute_service(BOOLEAN b_enable)
 {
-#if (BTA_AV_SINK_INCLUDED == TRUE)  
-        BTA_AvEnable_Sink(b_enable);
+#if (BTA_AV_SINK_INCLUDED == TRUE)
+    BTA_AvEnable_Sink(b_enable);
 #endif
     return BT_STATUS_SUCCESS;
 }
diff --git a/system/bt/btif/src/btif_dm.c b/system/bt/btif/src/btif_dm.c
index 1e60f53..fedad76 100644
--- a/system/bt/btif/src/btif_dm.c
+++ b/system/bt/btif/src/btif_dm.c
@@ -264,7 +264,7 @@ static void btif_dm_data_free(uint16_t event, tBTA_DM_SEC *dm_sec)
 bt_status_t btif_in_execute_service_request(tBTA_SERVICE_ID service_id,
                                                 BOOLEAN b_enable)
 {
-    BTIF_TRACE_DEBUG("%s service_id: %d, b_enable=%d", __FUNCTION__, service_id, b_enable);
+    BTIF_TRACE_DEBUG("%s service_id: %d", __FUNCTION__, service_id);
     /* Check the service_ID and invoke the profile's BT state changed API */
     switch (service_id)
     {
@@ -2924,9 +2924,9 @@ static void btif_dm_ble_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl)
             state = BT_BOND_STATE_NONE;
         } else {
             btif_dm_save_ble_bonding_keys();
+            BTA_GATTC_Refresh(bd_addr.address);
+            btif_dm_get_remote_services_by_transport(&bd_addr, BTA_GATT_TRANSPORT_LE);
         }
-        BTA_GATTC_Refresh(bd_addr.address);
-        btif_dm_get_remote_services_by_transport(&bd_addr, BTA_GATT_TRANSPORT_LE);
     }
     else
     {
diff --git a/system/bt/btif/src/btif_rc.c b/system/bt/btif/src/btif_rc.c
index cbb9162..a1928ee 100644
--- a/system/bt/btif/src/btif_rc.c
+++ b/system/bt/btif/src/btif_rc.c
@@ -40,7 +40,6 @@
 #include "hardware/bt_rc.h"
 #include "uinput.h"
 
-static bool s_is_mutex_destroy = 0;
 /*****************************************************************************
 **  Constants & Macros
 ******************************************************************************/
@@ -357,15 +356,18 @@ void handle_rc_features()
     {
         rc_features |= BTRC_FEAT_BROWSE;
     }
+
     if ( (btif_rc_cb.rc_features & BTA_AV_FEAT_ADV_CTRL) &&
          (btif_rc_cb.rc_features & BTA_AV_FEAT_RCTG))
     {
         rc_features |= BTRC_FEAT_ABSOLUTE_VOLUME;
     }
+
     if (btif_rc_cb.rc_features & BTA_AV_FEAT_METADATA)
     {
         rc_features |= BTRC_FEAT_METADATA;
     }
+
     BTIF_TRACE_DEBUG("%s: rc_features=0x%x", __FUNCTION__, rc_features);
     HAL_CBACK(bt_rc_callbacks, remote_features_cb, &rc_addr, rc_features)
 
@@ -485,7 +487,7 @@ void handle_rc_disconnect (tBTA_AV_RC_CLOSE *p_rc_close)
     bt_bdaddr_t rc_addr;
     tBTA_AV_FEAT features;
 #endif
-    BTIF_TRACE_ERROR("%s: rc_handle: %d", __FUNCTION__, p_rc_close->rc_handle);
+    BTIF_TRACE_DEBUG("%s: rc_handle: %d", __FUNCTION__, p_rc_close->rc_handle);
     if ((p_rc_close->rc_handle != btif_rc_cb.rc_handle)
         && (bdcmp(btif_rc_cb.rc_addr, p_rc_close->peer_addr)))
     {
@@ -504,7 +506,6 @@ void handle_rc_disconnect (tBTA_AV_RC_CLOSE *p_rc_close)
     btif_rc_cb.rc_vol_label=MAX_LABEL;
     btif_rc_cb.rc_volume=MAX_VOLUME;
     init_all_transactions();
-    BTIF_TRACE_ERROR("handle_rc_disconnect before close_uinput");
     close_uinput();
 #if (AVRC_CTLR_INCLUDED == TRUE)
     bdcpy(rc_addr.address, btif_rc_cb.rc_addr);
@@ -517,7 +518,6 @@ void handle_rc_disconnect (tBTA_AV_RC_CLOSE *p_rc_close)
             HAL_CBACK(bt_rc_ctrl_callbacks, connection_state_cb, FALSE, &rc_addr);
         }
     }
-    BTIF_TRACE_ERROR("handle_rc_disconnect finished!");
 #endif
 }
 
@@ -1747,11 +1747,6 @@ const btrc_ctrl_interface_t *btif_rc_ctrl_get_interface(void)
 *******************************************************************************/
 static void initialize_transaction(int lbl)
 {
-    if (s_is_mutex_destroy) {
-        BTIF_TRACE_DEBUG("initialize_transaction mutex detoried!");
-        return;
-    }
-    
     pthread_mutex_lock(&device.lbllock);
     if(lbl < MAX_TRANSACTIONS_PER_SESSION)
     {
@@ -1777,8 +1772,6 @@ void lbl_init()
     pthread_mutex_init(&(device.lbllock), &attr);
     pthread_mutexattr_destroy(&attr);
     init_all_transactions();
-
-    s_is_mutex_destroy = 0;
 }
 
 /*******************************************************************************
@@ -1894,7 +1887,6 @@ void release_transaction(UINT8 lbl)
 void lbl_destroy()
 {
     pthread_mutex_destroy(&(device.lbllock));
-    s_is_mutex_destroy = 1;
 }
 
 /*******************************************************************************
diff --git a/system/bt/btif/src/btif_storage.c b/system/bt/btif/src/btif_storage.c
index b0da6d5..83a5c2e 100644
--- a/system/bt/btif/src/btif_storage.c
+++ b/system/bt/btif/src/btif_storage.c
@@ -669,12 +669,6 @@ bt_status_t btif_storage_get_adapter_property(bt_property_t *property)
                                               p_uuid+num_uuids);
                             num_uuids++;
                         }break;
-                    case BTA_A2DP_SINK_SERVICE_ID:
-                        {
-                            uuid16_to_uuid128(UUID_SERVCLASS_AUDIO_SINK,
-                                              p_uuid+num_uuids);
-                            num_uuids++;
-                        }break;
                     case BTA_HFP_HS_SERVICE_ID:
                         {
                             uuid16_to_uuid128(UUID_SERVCLASS_HF_HANDSFREE,
diff --git a/system/bt/include/bt_target.h b/system/bt/include/bt_target.h
index e945f87..16605c6 100644
--- a/system/bt/include/bt_target.h
+++ b/system/bt/include/bt_target.h
@@ -88,7 +88,7 @@
 #endif
 
 #ifndef BTA_AV_SINK_INCLUDED
-#define BTA_AV_SINK_INCLUDED TRUE
+#define BTA_AV_SINK_INCLUDED FALSE
 #endif
 
 #ifndef BTA_DISABLE_DELAY
diff --git a/system/bt/main/Android.mk b/system/bt/main/Android.mk
index 64fba9c..0d2002f 100644
--- a/system/bt/main/Android.mk
+++ b/system/bt/main/Android.mk
@@ -113,24 +113,6 @@ LOCAL_C_INCLUDES+= . \
 	external/tinyxml2 \
 	external/zlib
 
-# sbc decoder
-LOCAL_SRC_FILES+= \
-	../embdrv/sbc/decoder/srce/alloc.c \
-	../embdrv/sbc/decoder/srce/bitalloc.c \
-	../embdrv/sbc/decoder/srce/bitalloc-sbc.c \
-	../embdrv/sbc/decoder/srce/bitstream-decode.c \
-	../embdrv/sbc/decoder/srce/decoder-oina.c \
-	../embdrv/sbc/decoder/srce/decoder-private.c \
-	../embdrv/sbc/decoder/srce/decoder-sbc.c \
-	../embdrv/sbc/decoder/srce/dequant.c \
-	../embdrv/sbc/decoder/srce/framing.c \
-	../embdrv/sbc/decoder/srce/framing-sbc.c \
-	../embdrv/sbc/decoder/srce/oi_codec_version.c \
-	../embdrv/sbc/decoder/srce/synthesis-sbc.c \
-	../embdrv/sbc/decoder/srce/synthesis-dct8.c \
-	../embdrv/sbc/decoder/srce/synthesis-8-generated.c \
-
-
 LOCAL_CFLAGS += -DBUILDCFG $(bdroid_CFLAGS) -Wno-error=maybe-uninitialized -Wno-error=uninitialized -Wno-error=unused-parameter
 LOCAL_CONLYFLAGS := -std=c99
 
diff --git a/system/bt/udrv/include/uipc.h b/system/bt/udrv/include/uipc.h
index 3ecf18a..b5efbd7 100644
--- a/system/bt/udrv/include/uipc.h
+++ b/system/bt/udrv/include/uipc.h
@@ -20,11 +20,9 @@
 
 #define UIPC_CH_ID_AV_CTRL  0
 #define UIPC_CH_ID_AV_AUDIO 1
-#define UIPC_CH_ID_AVK_CTRL  2
-#define UIPC_CH_ID_AVK_AUDIO 3
-#define UIPC_CH_NUM         4
+#define UIPC_CH_NUM         2
 
-#define UIPC_CH_ID_ALL      (UIPC_CH_NUM+1)   /* used to address all the ch id at once */
+#define UIPC_CH_ID_ALL      3   /* used to address all the ch id at once */
 
 #define DEFAULT_READ_POLL_TMO_MS 100
 
diff --git a/system/bt/udrv/ulinux/uipc.c b/system/bt/udrv/ulinux/uipc.c
index 9b63dcc..5a94d73 100644
--- a/system/bt/udrv/ulinux/uipc.c
+++ b/system/bt/udrv/ulinux/uipc.c
@@ -431,12 +431,6 @@ static void uipc_flush_locked(tUIPC_CH_ID ch_id)
         case UIPC_CH_ID_AV_AUDIO:
             uipc_flush_ch_locked(UIPC_CH_ID_AV_AUDIO);
             break;
-        case UIPC_CH_ID_AVK_CTRL:
-            uipc_flush_ch_locked(UIPC_CH_ID_AVK_CTRL);
-            break;
-        case UIPC_CH_ID_AVK_AUDIO:
-            uipc_flush_ch_locked(UIPC_CH_ID_AVK_AUDIO);
-            break;
     }
 }
 
@@ -638,15 +632,10 @@ BOOLEAN UIPC_Open(tUIPC_CH_ID ch_id, tUIPC_RCV_CBACK *p_cback)
         case UIPC_CH_ID_AV_CTRL:
             uipc_setup_server_locked(ch_id, A2DP_CTRL_PATH, p_cback);
             break;
+
         case UIPC_CH_ID_AV_AUDIO:
             uipc_setup_server_locked(ch_id, A2DP_DATA_PATH, p_cback);
             break;
-		case UIPC_CH_ID_AVK_CTRL:
-            uipc_setup_server_locked(ch_id, A2DP_SINK_CTRL_PATH, p_cback);
-            break;
-        case UIPC_CH_ID_AVK_AUDIO:
-            uipc_setup_server_locked(ch_id, A2DP_SINK_DATA_PATH, p_cback);
-            break;
     }
 
     UIPC_UNLOCK();
@@ -805,10 +794,10 @@ UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
 
         if (pfd.revents & (POLLHUP|POLLNVAL) )
         {
-            BTIF_TRACE_EVENT("poll : channel not detached remotely");
-            //UIPC_LOCK();
-            //uipc_close_locked(ch_id);
-            //UIPC_UNLOCK();
+            BTIF_TRACE_EVENT("poll : channel detached remotely");
+            UIPC_LOCK();
+            uipc_close_locked(ch_id);
+            UIPC_UNLOCK();
             return 0;
         }
 
@@ -819,9 +808,9 @@ UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
         if (n == 0)
         {
             BTIF_TRACE_EVENT("UIPC_Read : channel detached remotely");
-            //UIPC_LOCK();
-            //uipc_close_locked(ch_id);
-            //UIPC_UNLOCK();
+            UIPC_LOCK();
+            uipc_close_locked(ch_id);
+            UIPC_UNLOCK();
             return 0;
         }
 
diff --git a/system/media/audio/include/system/audio.h b/system/media/audio/include/system/audio.h
index 31404b7..2f33b2b 100644
--- a/system/media/audio/include/system/audio.h
+++ b/system/media/audio/include/system/audio.h
@@ -140,7 +140,6 @@ typedef enum {
                                           /* An example of remote presentation is Wifi Display */
                                           /*  where a dongle attached to a TV can be used to   */
                                           /*  play the mix captured by this audio source.      */
-	AUDIO_SOURCE_BLUETOOTH_A2DP		 = 9,									  
     AUDIO_SOURCE_CNT,
     AUDIO_SOURCE_MAX                 = AUDIO_SOURCE_CNT - 1,
     AUDIO_SOURCE_FM_TUNER            = 1998,
